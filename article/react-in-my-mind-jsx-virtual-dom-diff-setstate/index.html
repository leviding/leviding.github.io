<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="LeviDing's Blog，丁学文的博客。95 后，男生。果粉，不抽烟，有很多奇怪的想法，活跃在知乎和掘金，单身。"><title>React 之我见：JSX，虚拟 DOM，Diff 算法，setState，state 和 props 梳理 | LeviDing 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-92630037-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React 之我见：JSX，虚拟 DOM，Diff 算法，setState，state 和 props 梳理</h1><a id="logo" href="/.">LeviDing 的博客</a><p class="description">心之所向，身之所往！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-history"> 过往</i></a><a href="/guestbook/"><i class="fa fa-comment"> 留言</i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React 之我见：JSX，虚拟 DOM，Diff 算法，setState，state 和 props 梳理</h1><div class="post-meta">May 27, 2020<span> | </span><span class="category"><a href="/categories/前端技术/">前端技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="article/react-in-my-mind-jsx-virtual-dom-diff-setstate/" href="/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/#disqus_thread"></a><div class="post-content"><p>本文主要梳理一下我对 React 框架基础内容的认识，之后也会总结一些深度内容的认识。当然，笔者水平也有限，如果你发现不妥之处，望斧正！</p>
<a id="more"></a>


<h2 id="为什么要用-React-等前端框架"><a href="#为什么要用-React-等前端框架" class="headerlink" title="为什么要用 React 等前端框架"></a>为什么要用 React 等前端框架</h2><p>因为可以进行组件化开发？社区强大？使用的人多？有很多好用的第三方库和插件？适用于单页面应用开发？这些都不是最本质的原因。</p>
<p><strong>最本质的原因是保持 UI 和状态同步并不容易。</strong></p>
<p>使用原生 JavaScript 编写代码的时候，一般静态内容是在 HTML 中创建，动态内容使用 JavaScript 创建。但是使用 JavaScript 构建 UI 代码量巨大，并且可读性不高，代码可复用性也差。</p>
<p>更重要的是，如果我们想要保持 UI 和状态的同步应该怎么做？例如，我们有一个列表，我们需要实现将列表与服务器同步的功能。我们需要将本地数据和服务器发来的数据进行比较。并且需要点对点的将每个变更同步到 DOM 节点中。如果这个过程中有每一步出现差错都直接导致 UI 同步失败。因此，维护 UI 与数据同步需要编写大量繁琐，脆弱和脆弱的代码。</p>
<p>为了解决以上问题，降低开发成本，前端社区出现了 React 等框架。到目前为止，这些框架提供的最大的改进是实现应用状态和 UI 同步。我们只需要定义一次 UI，不必为每一次动作都编写 UI。相同的状态总能得到相同的 UI 输出，即状态和 UI 同步，状态变更后会自动更新 UI。</p>
<blockquote>
<p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/39852035" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39852035</a></p>
</blockquote>
<h2 id="React-VS-Vue"><a href="#React-VS-Vue" class="headerlink" title="React VS Vue"></a>React VS Vue</h2><p>很多人都说 React 上手要难一些，Vue 上手要简单一些。也有很多人在问 React 和 Vue 的区别是什么。我想说一下我的理解。</p>
<p>首先，在框架设计层面，React 是 MVC 软件架构中的 View，它只负责视图层的东西，而对于数据和路由等，则由 Redux 和 Router 等来完成。这也就是为什么 React 官方文档说 “React 是一个用于构建用户界面的 JavaScript 库”。而 Vue 则不同，Vue 是基于 MVVM 架构设计的一个框架，所以在架构层面，Vue 和 React 的思想就是不同的。</p>
<p>React 的设计哲学很简单，不可变（Immutable）思想贯穿了整个框架的设计。React 可以说没引进什么新的概念，让开发者能够以类似写原生 JavaScript 代码的方式来使用 React 进行开发。这也就是很多人说 React 难的原因，即 JavaScript 基础知识。</p>
<p>而很多人说 Vue 容易上手，可能有些同学就迷惑了，我觉得 Vue 不简单啊。笔者认为，说 Vue 简单是因为 Vue 将很多底层逻辑封装好了，直接给你对应的 API，你调用对应 API 就可以完成对应的工作。所以，你不需要有很扎实的 JavaScript 基础，你只要记住或者能够查阅到对应 API 就可以用 Vue 完成一些基础性的开发。所以有些后端的同学可以看看 Vue 官方文档就能上手基础的前端开发。</p>
<p>React 之我见，那一定要说我的看法，我喜欢 React。我喜欢其简洁的设计理念和类原生的开发体验，让我能够感觉到自己是在写代码。那么 Vue 我没有深入学习，但这是一个非常优秀的前端框架，目前也已经安排进了下一阶段的学习任务中。</p>
<h2 id="React-JSX，虚拟-DOM-和-ReactDOM-render"><a href="#React-JSX，虚拟-DOM-和-ReactDOM-render" class="headerlink" title="React JSX，虚拟 DOM 和 ReactDOM.render"></a>React JSX，虚拟 DOM 和 ReactDOM.render</h2><h3 id="JSX-和虚拟-DOM"><a href="#JSX-和虚拟-DOM" class="headerlink" title="JSX 和虚拟 DOM"></a>JSX 和虚拟 DOM</h3><p>JSX 和虚拟 DOM 是必说内容。JSX 也就是 JavaScript 的一个语法扩展，可以通过 Babel 对 JSX 进行转译。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如这样一段 JSX 代码会被 Babel 转译成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = React.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;,</span><br><span class="line">    <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看出，<code>React.createElement</code> 方法的参数是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createElement( tag, attrs, child1, child2, child3 );</span><br></pre></td></tr></table></figure>

<p>那么我们可以实现一下 <code>createElement</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params"> tag, attrs, ...children </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag,</span><br><span class="line">        attrs,</span><br><span class="line">        children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这样就可以对其进行调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将上文定义的 createElement 方法放到对象 React 中</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">    createElement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        hello&lt;span&gt;world!&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log( element );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处引用 <a href="https://github.com/hujiulong" target="_blank" rel="noopener">hujiulong</a> 的 <a href="https://github.com/hujiulong/blog/issues/4" target="_blank" rel="noopener">从零开始实现一个 React（一）：JSX 和虚拟 DOM</a>，详细内容推荐看其原文。</p>
</blockquote>
<p>也就是说，<code>createElement</code> 方法返回的东西就是所谓的虚拟 DOM。说到虚拟 DOM 就必说 diff 算法，这个我们之后再讲。</p>
<h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><p><code>render</code> 其实没有太多好说的，其作用就是将虚拟 DOM 渲染成真实的 DOM，只是在实现的过程中有非常多的细节情况要处理。</p>
<h2 id="React-组件和生命周期"><a href="#React-组件和生命周期" class="headerlink" title="React 组件和生命周期"></a>React 组件和生命周期</h2><p>在 React 中，我们可以通过 Class 和 Function 两种方式来写组件。以 Class 的方式写组件的时候，我们需要继承 React.Component。这里主要涉及 React.Component 的模拟实现和 React 的生命周期。模拟实现推荐看 <a href="https://github.com/hujiulong/blog/issues/5" target="_blank" rel="noopener">从零开始实现一个 React（二）：组件和生命周期</a>。至于 React 的生命周期，之后我会总结一篇文章，推荐大家去看 React 官方文档。</p>
<h2 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h2><p>为什么要 diff？因为 DOM 操作十分昂贵，也就是非常耗时耗性能。但是 DOM 操作就一定很慢很耗性能吗？其实不一定，只是普遍来讲是这样的，详细内容推荐看 JJC 的知乎回答：<a href="https://www.zhihu.com/question/324992717/answer/707044362" target="_blank" rel="noopener">前端为什么操作 DOM 是最耗性能的呢</a>。简单讲，浏览器中 DOM 对象是使用 C++ 开发的，性能肯定不慢，有些情况下性能甚至高于操作 JavaScript 对象。而大多数时候操作 DOM 是很耗性能的，这是因为 JavaScript 对象的属性（properties）映射到的是 DOM 对象的特性（attributes）上。</p>
<p>我们操作 JavaScript 对象只是修改一个对象，而修改 DOM 对象时还会修改对象的 attributes，那么性能就消耗在 JavaScript 对象和 DOM 对象的转换和同步上。并且，操作 DOM 还会影响页面的渲染，进而会再一次降低了性能。虽然 DOM 的性能有可能比操作普通对象还要快，但 99% 的场景下，操作 DOM 对象还是昂贵的。所以，高效的 diff 势在必行。</p>
<p>我们可以通过实现高效的 diff 算法，对比出操作前后有差异的 DOM 节点，然后只对更改了的 DOM 进行更新。这样可以大大减少没有必要的 DOM 操作，进而大幅提升性能。</p>
<p>React 的 diff 算法其实很简单：对比当前真实 DOM 和虚拟 DOM，在对比过程中直接更新真实 DOM。并且这个比对是同级比对，当发现这一级的 DOM 不同时，会直接更新该节点及其所有子节点。这种 diff 策略实际上是出于性能上的取舍。首先，DOM 操作很少出现跨层级的情况，所以只需要同级比对就可以满足大多数情况，也就没有必要对比所有的 DOM 节点，因为那样需要 O(n^3) 的时间复杂度，代价太高。</p>
<p>React 虚拟 DOM 的 Diff 原理的思维导图如下所示：</p>
<p><img src="https://i.loli.net/2020/06/27/Z1JR8hy7KEGsiLz.png" alt="React Virtual Dom Diff Algorithm"></p>
<p>React diff 算法的模拟实现推荐参见：<a href="https://github.com/hujiulong/blog/issues/6" target="_blank" rel="noopener">从零开始实现一个 React（三）：Diff 算法</a></p>
<h2 id="所谓异步的-setState"><a href="#所谓异步的-setState" class="headerlink" title="所谓异步的 setState"></a>所谓异步的 setState</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>首先明确，所谓异步的 setState 并不是真的异步，只是其行为类似于异步操作的行为。下面我们来详细说说。</p>
<p>首先，将 setState 的行为设置为所谓异步的形式的出发点依旧是性能优化，因为如果每次通过 setState 更改了状态都对组件进行一次更新，会很浪费性能。而通过将多次 setState 合并在一起，进行一次更新渲染，则会大大提升性能。</p>
<p>将多个 setState 的调用合并成一个来执行，也就意味着 state 并不会被立即更新。例如下面这例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            num: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState( &#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125; );</span><br><span class="line">            <span class="built_in">console</span>.log( <span class="keyword">this</span>.state.num );    <span class="comment">// 会输出什么？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">                &lt;h1&gt;&#123; <span class="keyword">this</span>.state.num &#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个组件 <code>APP</code>，在组件挂载后，会循环 100 次。但当我们真的对这个组件进行渲染会发现，渲染结果为 1，并且控制台中输出了 100 次 0。也就是说，每次循环中拿到的 state 都还是更新之前的。也就是说 React 对 setState 进行了优化，但如果我们就是想要立刻获得更新后的 state 怎么办呢？React 提供了一种解决方案，setState 接收的参数还可以是一个函数，通过这个函数我们可以拿到更新之前的状态，然后通过这个函数的返回值得到下一个状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState( <span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log( prevState.num );</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                num: prevState.num + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并-setState"><a href="#合并-setState" class="headerlink" title="合并 setState"></a>合并 setState</h3><p>对于这个地方，有两个要点：一是如何对多个 setState 调用进行合并。二是我怎么判定一次合并哪些 setState 呢？接下来我们一一解答。</p>
<p>setState 的合并是通过队列实现的。通过创建一个队列来保存每次 setState 的数据，然后每隔一段时间，清空和这个队列并渲染组件。此处的模拟实现推荐阅读：<a href="https://github.com/hujiulong/blog/issues/7" target="_blank" rel="noopener">从零开始实现一个 React（四）：异步的 setState</a></p>
<p>接下来就是一次到底合并哪些 setState。换句话说，我们会将一段时间内的 setState 调用合并成在一起执行，那么这段时间的长短取决于什么？其实此处使用的是 JavaScript 的事件队列机制，也就是事件循环（Event Loop）。关于事件循环的详细内容可参见阮一峰的 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈 Event Loop</a>。事件循环的核心概念就是同步任务，异步任务，微任务以及宏任务。</p>
<p>在 React 的 setState 中，利用 JavaScript 的事件循环机制对多个 setState 调用进行合并。首先创建一个队列保存每次 setState 的数据，在一次事件循环的所有同步任务之后，清空队列，将队列中的所有 setState 进行合并，并进行一次性更新渲染。这样在一次事件循环的，最多只会执行一次合并操作，并且只会渲染一次组件。</p>
<p>所以呢，这也就是为什么我说，所谓的 setState 的异步行为并不是真正的异步，只是不会对每一个 setState 操作进行实时更新，而是通过队列的方式对一次事件循环中的所有同步任务的 setState 调用进行合并，合并成一个之后进行一次更新和渲染，所以效果上看上去是异步的，但并不是 setTimeout 或 setInterval 这种真正的异步操作。</p>
<h3 id="关于-setState-同步异步的总结"><a href="#关于-setState-同步异步的总结" class="headerlink" title="关于 setState 同步异步的总结"></a>关于 setState 同步异步的总结</h3><ol>
<li><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</p>
</li>
<li><p>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。</p>
</li>
<li><p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p>
</li>
</ol>
<p>参考文章：<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener">https://juejin.im/post/5b45c57c51882519790c7441</a></p>
<h2 id="React-中-props-和-state-的关系"><a href="#React-中-props-和-state-的关系" class="headerlink" title="React 中 props 和 state 的关系"></a>React 中 props 和 state 的关系</h2><p>React 中的 props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的几个重要的不同点就是：</p>
<p>props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p>
<p>props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 由于 props 是传入的，并且它们不能更改，因此我们可以将任何仅使用 props 的 React 组件视为 pureComponent，也就是说，在相同的输入下，它将始终呈现相同的输出。</p>
<p>state 是在组件中创建的，一般在 constructor 中初始化 state。state 是多变的、可以修改，一般通过 setState 被修改，并且一般是异步更新的。</p>
<p>至此，React 的基本概念已经梳理完毕，感谢阅读。笔者水平有限，如果你发现任何问题，欢迎评论指正！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">React Dosc</a></li>
<li><a href="https://zh-hans.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">React 官方文档</a></li>
<li><a href="https://github.com/hujiulong/blog/issues/4" target="_blank" rel="noopener">从零开始实现一个 React（一）：JSX和虚拟DOM</a></li>
<li><a href="https://github.com/hujiulong/blog/issues/5" target="_blank" rel="noopener">从零开始实现一个 React（二）：组件和生命周期</a></li>
<li><a href="https://github.com/hujiulong/blog/issues/6" target="_blank" rel="noopener">从零开始实现一个 React（三）：Diff 算法</a></li>
<li><a href="https://github.com/hujiulong/blog/issues/7" target="_blank" rel="noopener">从零开始实现一个 React（四）：异步的 setState</a></li>
<li><a href="https://www.zhihu.com/question/324992717/answer/707044362" target="_blank" rel="noopener">前端为什么操作 DOM 是最耗性能的呢 —— JJC 的知乎回答</a></li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>LeviDing</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/">https://www.dingxuewen.com/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/React/">React</a></div><div class="post-nav"><a class="pre" href="/article/introduction-to-css-preprocessor/">初谈 CSS 预处理器</a><a class="next" href="/article/iterable-iterator-and-generator-of-javascript/">Iterable，Iterator，Generator 三者的区别与联系</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://www.dingxuewen.com/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/';
    this.page.identifier = 'article/react-in-my-mind-jsx-virtual-dom-diff-setstate/';
    this.page.title = 'React 之我见：JSX，虚拟 DOM，Diff 算法，setState，state 和 props 梳理';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//dingxuewen.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//dingxuewen.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://dingxuewen.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.dingxuewen.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-tasks"> 开源项目</i></div><ul></ul><a href="https://leviding.github.io/technical-talk" title="最新技术知识和趣闻" target="_blank">最新技术知识和趣闻</a><ul></ul><a href="https://zh.javascript.info" title="现代 JavaScript 教程" target="_blank">现代 JavaScript 教程</a><ul></ul><a href="https://leviding.github.io/leetcode-js-leviding" title="LeetCode JavaScript 题解" target="_blank">LeetCode JavaScript 题解</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder"> 文章分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础知识/">基础知识</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发总结/">开发总结</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考总结/">思考总结</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/文章翻译/">文章翻译</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/有趣好玩/">有趣好玩</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活随想/">生活随想</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目实战/">项目实战</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-tags"> 内容标签</i></div><div class="tagcloud"><a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/工作/" style="font-size: 15px;">工作</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/年度总结/" style="font-size: 15px;">年度总结</a> <a href="/tags/译文/" style="font-size: 15px;">译文</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Next/" style="font-size: 15px;">Next</a> <a href="/tags/Site/" style="font-size: 15px;">Site</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/多抓鱼/" style="font-size: 15px;">多抓鱼</a> <a href="/tags/文案/" style="font-size: 15px;">文案</a> <a href="/tags/管理/" style="font-size: 15px;">管理</a> <a href="/tags/营销/" style="font-size: 15px;">营销</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/Grid/" style="font-size: 15px;">Grid</a> <a href="/tags/微信读书/" style="font-size: 15px;">微信读书</a> <a href="/tags/运营/" style="font-size: 15px;">运营</a> <a href="/tags/市场/" style="font-size: 15px;">市场</a> <a href="/tags/微信/" style="font-size: 15px;">微信</a> <a href="/tags/热点/" style="font-size: 15px;">热点</a> <a href="/tags/工作技巧/" style="font-size: 15px;">工作技巧</a> <a href="/tags/PPT/" style="font-size: 15px;">PPT</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/Sass/" style="font-size: 15px;">Sass</a> <a href="/tags/Scss/" style="font-size: 15px;">Scss</a> <a href="/tags/Less/" style="font-size: 15px;">Less</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Chrome/" style="font-size: 15px;">Chrome</a> <a href="/tags/随想/" style="font-size: 15px;">随想</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/小米/" style="font-size: 15px;">小米</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/心理学/" style="font-size: 15px;">心理学</a> <a href="/tags/Sublime/" style="font-size: 15px;">Sublime</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/开源/" style="font-size: 15px;">开源</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/string-and-arr-methods/">字符串和数组常用方法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/article/resigned-from-alibaba-cloud/">我从阿里云离职了，下一站，广州</a></li><li class="post-list-item"><a class="post-list-link" href="/article/about-git-add/">git add .，git add -A，git add -u，git add * 的区别与联系</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020-annual-summary/">学文同学的 2020 年度总结</a></li><li class="post-list-item"><a class="post-list-link" href="/article/react-lifecycle-version-16-4/">我对 React V16.4 生命周期的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/article/introduction-to-css-preprocessor/">初谈 CSS 预处理器</a></li><li class="post-list-item"><a class="post-list-link" href="/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/">React 之我见：JSX，虚拟 DOM，Diff 算法，setState，state 和 props 梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/article/iterable-iterator-and-generator-of-javascript/">Iterable，Iterator，Generator 三者的区别与联系</a></li><li class="post-list-item"><a class="post-list-link" href="/article/how-to-quickly-attract-judges-in-a-5-minute-ppt-report/">如何在 5 分钟 PPT 汇报中迅速抓住评委眼球</a></li><li class="post-list-item"><a class="post-list-link" href="/article/do-you-really-know-how-to-write-a-good-copy/">你真的知道怎么写文案吗 —《文案训练手册》</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//dingxuewen.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-list"> 社交账号</i></div><ul></ul><a href="https://leviding.com" title="LeviDing.com" target="_blank">LeviDing.com</a><ul></ul><a href="https://github.com/leviding" title="我的「GitHub」" target="_blank">我的「GitHub」</a><ul></ul><a href="https://juejin.im/user/589881b7128fe1006cbbacec/posts" title="我的「掘金」主页" target="_blank">我的「掘金」主页</a><ul></ul><a href="https://www.zhihu.com/people/leviding" title="我的「知乎」主页" target="_blank">我的「知乎」主页</a><ul></ul><a href="https://weibo.com/leviding" title="我的「微博」主页" target="_blank">我的「微博」主页</a><ul></ul><a href="https://www.douban.com/people/dingxuewen/" title="我的「豆瓣」主页" target="_blank">我的「豆瓣」主页</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017-2023 LeviDing.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>