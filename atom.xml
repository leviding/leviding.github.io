<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeviDing 的博客</title>
  
  <subtitle>心之所向，身之所往！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dingxuewen.com/"/>
  <updated>2023-02-08T09:52:15.507Z</updated>
  <id>https://www.dingxuewen.com/</id>
  
  <author>
    <name>LeviDing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串和数组常用方法总结</title>
    <link href="https://www.dingxuewen.com/article/string-and-arr-methods/"/>
    <id>https://www.dingxuewen.com/article/string-and-arr-methods/</id>
    <published>2022-07-15T14:00:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，字符串和数组的方法特别多，日常也是最长用到的，所以梳理一下，加强记忆。</p><a id="more"></a><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><ol><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf" target="_blank" rel="noopener">str.indexOf(substr, pos)</a>：从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。</p></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf" target="_blank" rel="noopener">str.lastIndexOf(substr, position)</a>：从字符串的末尾开始搜索到开头。</p></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" rel="noopener">str.includes(substr, pos)</a>：根据 <code>str</code> 中是否包含 <code>substr</code> 来返回 <code>true/false</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" target="_blank" rel="noopener">str.startsWith(substr)</a>：返回 <code>true/false</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" target="_blank" rel="noopener">str.endsWith(substr)</a>：返回 <code>true/false</code>。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice" target="_blank" rel="noopener">str.slice(start [, end])</a>：返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。</p><blockquote><ul><li>对原数据 <strong>无修改</strong></li><li><code>start/end</code> 可以是负值，表示起始位置从字符串结尾计算</li></ul></blockquote></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring" target="_blank" rel="noopener">str.substring(start [, end])</a>：返回字符串从 <code>start</code> 到（但不包括） <code>end</code> 的部分。这与 <code>slice</code> 几乎相同，但它允许 <code>start</code> 大于 <code>end</code>。</p><blockquote><ul><li>对原数据 <strong>无修改</strong></li><li>不支持负参数，会被视为 <code>0</code>。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"stringify"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些对于 substring 是相同的</span></span><br><span class="line">alert( str.substring(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// "ring"</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// "ring"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……但对 slice 是不同的：</span></span><br><span class="line">alert( str.slice(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// "ring"（一样）</span></span><br><span class="line">alert( str.slice(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// ""（空字符串）</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="noopener">str.substr(start [, length])</a>：返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。</p><blockquote><ul><li>对原数据 <strong>无修改</strong></li><li><code>start</code> 可以是负数，从结尾算起。</li><li>非核心规范内容，而是在附录 B 中</li></ul></blockquote></li></ol><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><ol><li><p><code>arr.at(i)</code>：返回数组 <code>arr</code> 索引 <code>index</code> 对应的元素。如果 <code>i &gt;= 0</code>，则与 <code>arr[i]</code> 完全相同。<code>i</code> 为负数则从数组的末端向前数。</p></li><li><p><code>arr.push(item1, item2, ...)</code>：在末端添加元素 <code>item</code>，return <code>arr.length</code></p><blockquote><ul><li>对原数据 <strong>有修改</strong></li></ul></blockquote></li><li><p><code>arr.pop()</code>：从末端取出一个元素，return 取出的元素</p><blockquote><ul><li>对原数据 <strong>有修改</strong></li></ul></blockquote></li><li><p><code>arr.shift()</code>：从首端取出一个元素，return 取出的元素</p><blockquote><ul><li>对原数据 <strong>有修改</strong></li></ul></blockquote></li><li><p><code>arr.unshift(item1, item2, ...)</code>：在首端添加元素 <code>item</code>，return <code>arr.length</code></p><blockquote><ul><li>对原数据 <strong>有修改</strong></li></ul></blockquote></li><li><p><code>arr.indexOf/lastIndexOf(item, from)</code>：从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</p></li><li><p><code>arr.includes(item, from)</code>：从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>，否则返回 <code>false</code>。</p><blockquote><ul><li>可以正确识别 <code>NaN</code>，但 <code>indexOf/lastIndexOf</code> 不行</li></ul></blockquote></li><li><p><code>arr.splice(start[, deleteCount, elem1, ..., elemN])</code>：从索引 <code>start</code> 开始修改 <code>arr</code>：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后返回被删除的元素所组成的数组。</p><blockquote><ul><li>对原数据 <strong>有修改</strong></li><li>允许负数索引，从数组末尾开始计算位置</li></ul></blockquote></li><li><p><code>arr.slice([start], [end])</code>：索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组并返回。</p><blockquote><ul><li>对原数据 <strong>无修改</strong></li><li>两个索引均可为负数，从末尾计算索引。</li></ul></blockquote></li><li><p><code>arr.concat(arg1, arg2...)</code>：接受任意数量的参数（数组或值都可以），创建一个新数组，其中包含所有参数的值。</p><blockquote><ul><li>对原数据 <strong>无修改</strong></li><li>通常只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"something"</span>,</span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat(arrayLike) ); <span class="comment">// 1,2,[object Object]</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>除非类数组对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理：</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"something"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"else"</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat(arrayLike) ); <span class="comment">// 1,2,something,else</span></span><br></pre></td></tr></table></figure></li><li><p><code>arr.forEach((item, index, array) =&gt; { ...对 item 进行处理 })</code>：无返回值</p></li><li><p><code>arr.find((item, index, array) =&gt; {})</code>：返回 <code>true</code> 则停止搜索并返回 <code>item</code>，否则返回 <code>undefined</code>。</p></li><li><p><code>arr.findIndex/findLastIndex((item, index, array) =&gt; {})</code>：与 <code>arr.find</code> 基本相同，但返回找到的元素的 <code>index</code> 而不是 <code>item</code>，没找到则返回 <code>-1</code>。</p></li><li><p><code>let results = arr.filter((item, index, array) =&gt; {});</code>：处理函数中 <code>return true</code> 则会将 <code>item push</code> 到 <code>results</code>，如果没有符合条件的，则 <code>results</code> 为空数组。</p></li><li><p><code>map((item, index, array) =&gt; {})</code>：返回结果数组</p></li><li><p><code>arr.sort(func)</code>：对数组进行原位排序</p><blockquote><ul><li>对原数据 <strong>有修改</strong></li></ul></blockquote></li><li><p><code>arr.reverse()</code>：颠倒 <code>arr</code> 中元素的顺序</p><blockquote><ul><li>对原数据 <strong>有修改</strong></li></ul></blockquote></li><li><p><code>arr.split(delim)</code></p></li><li><p><code>arr.join(glue)</code></p></li><li><p><code>arr.reduce((accumulator, item, index, array) =&gt; {}, [initial])</code>：</p><blockquote><ul><li><code>accumulator</code> 是上一个函数调用的结果，第一次等于 <code>initial</code>（如果提供了 <code>initial</code>）</li><li><code>arr.reduceRight</code> 和 <code>arr.reduce</code> 方法功能一样，只是遍历从右到左</li></ul></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中，字符串和数组的方法特别多，日常也是最长用到的，所以梳理一下，加强记忆。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://www.dingxuewen.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="https://www.dingxuewen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>我从阿里云离职了，下一站，广州</title>
    <link href="https://www.dingxuewen.com/article/resigned-from-alibaba-cloud/"/>
    <id>https://www.dingxuewen.com/article/resigned-from-alibaba-cloud/</id>
    <published>2022-07-09T10:06:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>原本我在离职前已写好一篇离职帖，并发在了内网，想着稍作修改发至公网作为这段经历的纪念。没成想，我一不小心把留存的源文件删了😅，内网又进不去，只能重新写一篇。哈哈，也好，可以让我再重新整理一下。</p><a id="more"></a><p>2021 年 01 月 18 日，我作为签定了三方的同学入职了阿里云（杭州）实习。2021 年 07 月 05 日，结束实习，正式入职。2022 年 07 月 06 日，正式离职，结束了这段阿里之旅，共计 367 天（535 天）。</p><p>离职前的这一周，收到了 Leader 送的周年纪念品和公司给的“一年香”徽章及工牌带，谢谢 Leader，谢谢公司。</p><p><img src="https://images.dingxuewen.com/20220710004625Leader%20%E9%80%81%E7%9A%84%E5%91%A8%E5%B9%B4%E7%BA%AA%E5%BF%B5%E5%93%81.jpeg?imageMogr2/auto-orient/format/jpg/interlace/1/blur/1x0/quality/45" alt="Leader 送的周年纪念品"></p><p><img src="https://images.dingxuewen.com/20220710004802%E9%98%BF%E9%87%8C%E4%B8%80%E5%B9%B4%E9%A6%99.jpeg?imageMogr2/auto-orient/format/jpg/interlace/1/blur/1x0/quality/45" alt="阿里一年香"></p><p>还记得我参加校招面试的时候，有面试官问过我：“你工作之后最想获得什么？”我答：“加深技术深度，拓宽技术广度。”但面试官语重心长地说：“你工作之后会发现，技术并不是最重要的。”现在的我切实感受到了，技术重要，但确实不是最重要的。技术要为业务服务，通过业务拿到了好结果，才能更好地体现技术的价值。</p><p>还记得参加工作之前，我认为赚钱是最重要的，但工作之后恰逢疫情反复，切身感受到一家人平安、幸福、快乐才是最重要的。在过去一年多的时间里，我和老婆分居两地，平均两周见一次，聚少离多。每次见面最头疼的不仅是往返近 18 小时的距离，还有疫情政策的变幻无常。因为杭州和广州在两个省，属于跨省通行，所以在政策上更为严格。每次见面不仅要安排出行时间、买票，还要分别查询两个城市的疫情政策，且不乏定好了行程之后出现突发状况导致无法出行。所以，我辞职来广州了。</p><p>在过去一年多的时间里，因为异地，我们两个人成了飞机、高铁的“常客”。一开始她趁着公司有苏州的出差机会，申请到苏州出差了两个多月，这样我们每周坐一个多小时的高铁就能见面了。项目结束后，我们就大多乘飞机见面。下图是我的乘机航线图，她的乘机次数比我的还多。在异地的这段时间里，她来找我的次数比我找她的次数多很多，以至于有朋友说“一直都是看你老婆来找你”，哈哈哈。</p><img src="https://images.dingxuewen.com/20220710004828WechatIMG41.jpeg?imageMogr2/auto-orient/format/jpg/interlace/1/blur/1x0/quality/45" alt="我的乘机航线图" style="zoom:33%;"><p>记得有一次，她从杭州回广州，坐地铁到了萧山机场却发现必须要核酸报告，因为前一天更新了政策，但航空公司没通知我们，我们也没注意到。如果是我遇到这样的事，我肯定非常生气，甚至迁怒于对方。但她在告诉我这件事的时候，语气没有丝毫不好，而是说：“我们又可以待一天啦，晚上我们一起去吃猪肚鸡好不。”我知道她也烦、也累，她坐了两个小时地铁才到机场又得坐回来，明天还得再坐两个小时地铁过去。曾经有同事问我，是什么让你决定结婚，我没有回答，现在我想说，可能就是这样的点点滴滴吧。</p><p>当然，在职一年多，从熟悉团队、熟悉项目，到成为了项目 owner。离职则意味着失去了熟悉的团队，熟悉的项目，要重新找工作并融入。但是，哪有两全齐美的事，不都是有得有失嘛。新的风险和挑战，也就意味着新的机遇，我相信自己！</p><p>谈完了现状，那么也分享一下我接下来的安排。在过去一年多的时间里，我自认为无论是在技术上，还是在工作的方式方法上，都有了极大的成长，但也存在着知其然不知其所以然的部分。所以我想用一个月到一个半月的时间，整理这一年多以来的所学所想，并搞定之前不知其所以然的部分。再重新过一遍 HTML、CSS、JavaScript 巩固基础。学习学习算法、Node、Webpack、Vite 和计算机基础等相关知识。</p><p>此外，我维护的<a href="https://github.com/javascript-tutorial/zh.javascript.info" target="_blank" rel="noopener">《现代 JavaScript 教程》</a>也有一定的待更新量，这段时间我再把教程系统地更新一下。之后我计划以每月一版的更新节奏，形成月报发布出来。</p><p><img src="https://images.dingxuewen.com/20220710004929%E7%8E%B0%E4%BB%A3%20JavaScript%20%E6%95%99%E7%A8%8B%20GitHub.png?imageMogr2/auto-orient/format/jpg/interlace/1/blur/1x0/quality/45" alt="现代 JavaScript 教程 GitHub"></p><p>学习是一方面，代码也不能放下。在学习的过程中也要多实际操练操练，多总结，多分享。</p><p>预计在八月中下旬，开始投递简历，寻找下一份工作。我期望能够找到在业务上有前景，我认可，也认可我的一份工作和一群人。</p><p>凡是过往，皆为序章。</p><p>学文来啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原本我在离职前已写好一篇离职帖，并发在了内网，想着稍作修改发至公网作为这段经历的纪念。没成想，我一不小心把留存的源文件删了😅，内网又进不去，只能重新写一篇。哈哈，也好，可以让我再重新整理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="https://www.dingxuewen.com/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="成长" scheme="https://www.dingxuewen.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="工作" scheme="https://www.dingxuewen.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="思考" scheme="https://www.dingxuewen.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>git add .，git add -A，git add -u，git add * 的区别与联系</title>
    <link href="https://www.dingxuewen.com/article/about-git-add/"/>
    <id>https://www.dingxuewen.com/article/about-git-add/</id>
    <published>2022-01-16T15:49:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>Git 的使用：归纳整理一些 git 使用的细节</p><a id="more"></a><blockquote><p>注意：这几个命令在不同版本的 Git 中稍有差异。</p></blockquote><h3 id="对于-Git-Version-1-x："><a href="#对于-Git-Version-1-x：" class="headerlink" title="对于 Git Version 1.x："></a>对于 Git Version 1.x：</h3><ol><li><code>git add .</code>：会将当前工作区中当前目录(包括子目录)下的所有新文件和对已有文件的改动提交至暂存区，但不包括被删除的文件。</li><li><code>git add -u</code>：<code>git add --update</code> 的简写形式，它只会监控当前整个工作区中之前已被 <code>add</code> 的文件，即已被跟踪(tracked)的文件，也就是只会将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区。</li><li><code>git add -A</code>：<code>git add --all</code> 的简写形式，它会将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制。</li></ol><p>注意：你会看到有些文章说 <code>git add -A</code> 属于 <code>git add .</code> 和 <code>git add -u</code> 功能的合集，这是不对的。因为 <code>git add .</code> 只会提交当前目录(包括子目录)下的新文件和对已有文件的改动，而 <code>git add -A</code> 不受当前目录限制。也就是说，<code>git add .</code> 和 <code>git add -u</code> 功能的合集只能属于 <code>git add -A</code> 功能的子集。</p><p><strong>总结详见下图：</strong></p><table><thead><tr><th align="left">Git Version 1.x</th><th align="center">新文件</th><th align="center">被修改的文件</th><th align="center">被删除的文件</th><th>是否受当前所在目录限制</th><th>说明</th></tr></thead><tbody><tr><td align="left">git add -A.</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td>❌</td><td>将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制</td></tr><tr><td align="left">git add .</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td>✅</td><td>将当前工作区中当前目录(包括子目录)下的所有新文件和对已有文件的改动提交至暂存区，但不包括被删除的文件</td></tr><tr><td align="left">git add -u.</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td>❌</td><td>将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区</td></tr></tbody></table><h3 id="对于-Git-Version-2-x："><a href="#对于-Git-Version-2-x：" class="headerlink" title="对于 Git Version 2.x："></a>对于 Git Version 2.x：</h3><p>在 Git –version 2.x 中对 <code>git add .</code> 的功能做了改动，<code>git add .</code> 会提交当前工作区中当前目录(包括子目录)下所有的文件改动，不像在 Git –version 1.x 时那样不包括被删除的文件。</p><p>Git Version 2.x 中如果想在使用 <code>git add .</code> 时不提交被删除的文件，可以使用 <code>git add --ignore-removal</code> 加上匹配符 <code>.</code>，即 <code>git add --ignore-removal .</code>。</p><p><code>git add --ignore-removal</code> 后的匹配符是可以更换的(但不能缺省)，例如 <code>git add --ignore-removal -A</code> 可以实现在 <code>git add -A</code> 时不提交被删除的文件。</p><p>有些文章说在 Git –version 2.x 中 <code>git add .</code> 和 <code>git add -A</code> 的功能变得完全相同，这是不对的。因为我们之前提到过，<code>git add .</code> 提交的文件改动受当前所在目录限制，它只会提交当前工作区中当前目录(包括子目录)下的文件改动，而 <code>git add -A</code> 不受当前所在目录的限制，提交的是当前整个工作区中所有的文件改动。</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add *"></a>git add *</h4><p><code>git add *</code> 表示添加当前目录(包括子目录)下的所有文件改动，但不包括文件名以 <code>.</code> 符号开头的文件的改动。这是 Shell 命令，git 只是接收文件列表。而 <code>git add .</code> 的功能与 <code>git add *</code> 基本相同，只是 <code>git add .</code> 会将文件名以 <code>.</code> 符号开头的文件的改动也提交至暂存区。</p><p><strong>总结详见下图：</strong></p><table><thead><tr><th align="left">Git Version 2.x</th><th align="center">新文件</th><th align="center">被修改的文件</th><th align="center">被删除的文件</th><th>是否受当前所在目录限制</th><th>说明</th></tr></thead><tbody><tr><td align="left">git add -A</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td>❌</td><td>将当前整个工作区中所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，不受当前所在目录限制</td></tr><tr><td align="left">git add .</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td>✅</td><td>将当前工作区中当前目录(包括子目录)下的所有的文件改动提交至暂存区，包括新增、修改和被删除的文件</td></tr><tr><td align="left">git add -u.</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td>❌</td><td>将当前整个工作区中被修改和被删除的文件提交至暂存区。而新文件因为未被跟踪(untracked)，所以不会被提交至暂存区</td></tr><tr><td align="left">git add *</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td>✅</td><td>将当前工作区中当前目录(包括子目录)下的所有的文件改动提交至暂存区，包括新增、修改和被删除的文件，但不包括文件名以 <code>.</code> 符号开头的文件的改动</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 的使用：归纳整理一些 git 使用的细节&lt;/p&gt;
    
    </summary>
    
      <category term="开发总结" scheme="https://www.dingxuewen.com/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Git" scheme="https://www.dingxuewen.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>学文同学的 2020 年度总结</title>
    <link href="https://www.dingxuewen.com/article/2020-annual-summary/"/>
    <id>https://www.dingxuewen.com/article/2020-annual-summary/</id>
    <published>2021-02-11T05:36:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>这是我第一次正经写年度总结，之前一直有这个想法，但却没认真实践。希望今后每年自己都能通过年度总结的方式，对一年来的学习、工作、生活和成长进行回顾，为下一年做出规划和展望。</p><a id="more"></a><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>我是学文同学，2021 应届生，全网统一 ID：LeviDing，95 后，东北人。现为 <a href="https://github.com/javascript-tutorial/zh.javascript.info" target="_blank" rel="noopener">现代 JavaScript 教程</a> 负责人，公众号：<a href="https://user-images.githubusercontent.com/26959437/103859492-184f6c80-50f5-11eb-8187-a94b4302403f.png" target="_blank" rel="noopener">技术漫谈</a> 和 <a href="https://user-images.githubusercontent.com/26959437/103859917-d672f600-50f5-11eb-9cd5-fb059ec15eb8.png" target="_blank" rel="noopener">编程每日一题</a> 运营者，前 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 负责人，在 <a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a>、<a href="https://juejin.cn/" target="_blank" rel="noopener">掘金</a> 和 <a href="https://modao.cc/" target="_blank" rel="noopener">墨刀</a> 实习过。本科做的嵌入式开发，硕士做的机器学习，现从事前端开发，努力成为一名全栈开发者，希望能够做出对世界有一点点贡献的产品。喜欢旅行，摄影，骑行，读书，电影，掌机游戏。</p><h2 id="2020-年回顾和总结"><a href="#2020-年回顾和总结" class="headerlink" title="2020 年回顾和总结"></a>2020 年回顾和总结</h2><h3 id="我的-2020-时间线"><a href="#我的-2020-时间线" class="headerlink" title="我的 2020 时间线"></a>我的 2020 时间线</h3><ol><li><strong>1 月初 - 1 月中</strong>：在学校，待到 2020 年 01 月 15 号学校放寒假，回家；</li><li><strong>1 月中 - 8 月初</strong>：因为疫情爆发，直到今年的八月初，我一直都待在家里，主要是做学校的东西，维护开源项目，学前端，找工作；</li><li><strong>8 月初 - 9 月初</strong>：北京墨刀实习，前端开发，秋招；</li><li><strong>9 月初 - 12 月底</strong>：在学校，做学校的东西，完成秋招。</li></ol><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>今年算是真正系统学习前端知识，把 JavaScript 过了一遍，系统学习了 React 相关内容。但还有很多欠缺和不足，2021 要在 React 相关项目、ECMAScript 规范、CSS、Node.js 等方面多下功夫。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>今年我没有参加春招，直接参加了秋招。我觉得自己算是很幸运的，八月初开始参加笔试，中旬开始陆续面试，下旬开始陆续收到意向书和 offer。九月中旬完成了所有面试并收到了大部分意向书，下旬收到了所有意向书。十月、十一月谈薪和签约，十二月签三方。</p><p>总体上我就投递了一个批次，面试了大概十家公司，拿到阿里云、拼多多、网易、京东、好未来、斗鱼、顺丰和小鹏汽车 8 个 offer，包括多个 SP，最后签了阿里云。拿到了自己想去的公司，所以就没再投其他公司了，像腾讯、百度、快手、滴滴等公司都没投。感觉自己的技术水平其实挺菜的，感谢面试官对我的认可，面试体验非常好，受益匪浅。</p><p>在这里感谢其昌大哥，心雨同学，勤恩师兄，叔平老兄，三金哥，科总，涛哥，涵兄，所有面试官和校招组的同学，还有很多很多人 👏👏👏</p><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>今年我在开源项目上的投入主要是 <a href="https://github.com/javascript-tutorial/zh.javascript.info" target="_blank" rel="noopener">现代 JavaScript 教程</a>。项目创建于 2018 年 04 月，到现在有 Watch：101，Star：4133，Fork：612。在过去的一年里，Star 数从 2000 多涨到了 4000 多，翻了一倍。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a27048f5fa60430ab48c66ba555335bd~tplv-k3u1fbpfcp-watermark.image" alt="项目 Star 数变化趋势图"></p><p>今年我把整个教程重新翻译了一遍，花费了很多时间和精力，当然也收获了很多，帮助到了很多同学。目前还剩最后一小部分没优化完，接下来需要做的就是优化完剩余内容，并及时对教程进行跟进和更新，并修复发现的一些问题。</p><h3 id="社区影响力"><a href="#社区影响力" class="headerlink" title="社区影响力"></a>社区影响力</h3><p>今年在这方面做的事主要有三个：</p><ol><li>创建并运营掘金号 <a href="https://juejin.cn/user/1451011080718557" target="_blank" rel="noopener">技术漫谈</a>，截至撰写本文时，有 2035 关注者；</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03cf6cf827fb4310bc89d56fc5c38b3f~tplv-k3u1fbpfcp-watermark.image" alt></p><ol start="2"><li><p>从 2020-06-25 号开始持续运营微信公众号 <a href="https://user-images.githubusercontent.com/26959437/103859492-184f6c80-50f5-11eb-8187-a94b4302403f.png" target="_blank" rel="noopener">技术漫谈</a>，截至撰写本文时有 4000+ 关注者；</p></li><li><p>组织并参与翻译的《Python 机器学习》一书进入了最后的出版校订环节。</p></li></ol><p>在这儿也对今年在社区各渠道的数据做一个记录：</p><ol><li>掘金号 <a href="https://juejin.cn/user/3949101465995197/posts" target="_blank" rel="noopener">LeviDing</a>：15506 关注者；</li><li>掘金号 <a href="https://juejin.cn/user/1451011080718557" target="_blank" rel="noopener">技术漫谈</a>：2035 关注者；</li><li>GitHub <a href="https://github.com/leviding" target="_blank" rel="noopener">LeviDing</a>：392 Follower；</li><li>知乎 <a href="https://www.zhihu.com/people/leviding" target="_blank" rel="noopener">LeviDing</a>：13158 关注者；</li><li>微信公众号 <a href="https://user-images.githubusercontent.com/26959437/103859492-184f6c80-50f5-11eb-8187-a94b4302403f.png" target="_blank" rel="noopener">技术漫谈</a>：4018 关注者；</li><li>微信公众号 <a href="https://user-images.githubusercontent.com/26959437/103859917-d672f600-50f5-11eb-9cd5-fb059ec15eb8.png" target="_blank" rel="noopener">编程每日一题</a>：319 关注者。</li></ol><h3 id="自媒体"><a href="#自媒体" class="headerlink" title="自媒体"></a>自媒体</h3><p>自媒体包括但不限于微信公众号。2020 年 07 月 06 号开始通过自媒体有了第一笔收入，截至目前，这 7 个月内收入 19910 元。我接的广告都是筛选过的，坑人的广告一律不接。</p><p>当然，我坚信人要舍得，有舍才有得。所以我今年通过公众号和朋友圈赠送了约 1500 元的书，发了 3000 块左右的红包。在接下来的这一年里，希望能给关注我的人带来更多的福利。</p><p>今年做了 6 次送书活动，做了 6 次公众号互推（2020-10-29 第一次互推），做了大概 5 次朋友圈互推。</p><h3 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h3><p>在学校做的东西写过研究所内的年度总结，对我个人来讲有意义的就是，完成了自己的一篇大论文并投稿了 <a href="https://cis.ieee.org/publications/t-cognitive-and-developmental-systems" target="_blank" rel="noopener">IEEE Transactions on Cognitive and Developmental Systems</a>，期望能有一个好的结果。</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>我认为，对理财收益影响最大的因素是市场，其次是个人的价值取向和对趋势的判断。在疫情爆发之初，股市大跌，我没有减仓，反而加仓，尤其是消费和医疗板块。</p><p>因为随着人们生活水平的提高和人口老龄化，对医疗的需求肯定会越来越大。而疫情导致消费被大幅削弱，但在疫情后的消费肯定会逐步恢复。并且在扩大内需的宏观调控下，消费板块未来可期。当然有赌的成分，但是有底层逻辑的。</p><p>2020 年行情不错，我一开始的仓位分布不是太好，逐步调整优化，年收益率 34.74%。2021 春节前这一个半月收益率 15.04%，总体也就是 50% 左右。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>今年还是看了很多电影，到目前为止，国产的好电影基本都看过了，国外的大部分都看过了。之后再看书看电影啥的在豆瓣记一下，这样就能有个统计。</p><p>今年新买了 20 多个 Switch 大作卡带，现在一共有 50 多个，感觉收藏的占比大一些，根本没时间玩那么多 😂</p><p>今年玩儿的最多的游戏是塞尔达传说和动物森友会，两个游戏合计时常 700 小时左右吧。</p><p>这张图是玩儿塞尔达的时候印象最深也是最感动的一幕，这游戏太长，才玩儿了一小部分，森林里摸鱼、打怪、做菜，就是不去救公主 😂</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678e1062b0c844b9811190b26fa11124~tplv-k3u1fbpfcp-watermark.image" alt></p><p>下面这张图是我动森里的小家，中式园林 😛</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a68197a8bc948f59f063e417b77aade~tplv-k3u1fbpfcp-watermark.image" alt></p><p>今年新购设备：</p><ul><li>AirPods Pro</li><li>Homepod mini</li><li>戴森吸尘器 V10</li><li>小米空气净化器</li><li>其他小米传感器啥的</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>结束了学校的学生会副主席的工作，好好搞技术，搞学习。</p><h2 id="展望-2021"><a href="#展望-2021" class="headerlink" title="展望 2021"></a>展望 2021</h2><p>总结完了 2020，再展望一下 2021。下面列的不是 flag，而是今年的重点投入方向。</p><ol><li>完成好毕业论文和答辩，顺利毕业；</li><li>提升前端技术，毕业后入职，尽快上手工作。希望顺利通过试用期，在组内能扛起责任，做出贡献；</li><li>维护好 <a href="https://github.com/javascript-tutorial/zh.javascript.info" target="_blank" rel="noopener">现代 JavaScript 教程</a>，输出更多优质内容，维护好「技术漫谈」公众号；</li><li>做「编程每日一题」开源项目和微信公众号；</li><li>学习 Node.js 和 Java 相关的后端知识，最好能做一个「前端 + 后端 + 算法」的综合型技术开源项目；</li><li>继续学习理财，收益目标就不定了，市场影响因素太大；</li><li>搞搞家居物联网；</li><li>至少一次远途旅行；</li><li>努力变得更加主动，认识更多的人；</li><li>读书；</li><li>多刷刷 LeetCode，锻炼编程思维；</li><li>开始把 <a href="https://github.com/javascript-tutorial/zh.javascript.info" target="_blank" rel="noopener">现代 JavaScript 教程</a> 视频化，同时也做做其他相关的长短视频。</li></ol><h2 id="感谢和祝福"><a href="#感谢和祝福" class="headerlink" title="感谢和祝福"></a>感谢和祝福</h2><p>感谢一年来我所遇到的所有人，谢谢你们。也谢谢所有关注我的人，祝大家新的一年里身体健康，心想事成，天天开心，学习进步，工作顺利 😘</p><p>新年快乐 🧨🧨🧨🧨🧨🧨</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次正经写年度总结，之前一直有这个想法，但却没认真实践。希望今后每年自己都能通过年度总结的方式，对一年来的学习、工作、生活和成长进行回顾，为下一年做出规划和展望。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="https://www.dingxuewen.com/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="成长" scheme="https://www.dingxuewen.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="工作" scheme="https://www.dingxuewen.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="思考" scheme="https://www.dingxuewen.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="总结" scheme="https://www.dingxuewen.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="年度总结" scheme="https://www.dingxuewen.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我对 React V16.4 生命周期的理解</title>
    <link href="https://www.dingxuewen.com/article/react-lifecycle-version-16-4/"/>
    <id>https://www.dingxuewen.com/article/react-lifecycle-version-16-4/</id>
    <published>2020-06-26T15:10:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>网上有很多关于 React 生命周期的文章，我也看了不少，为了梳理并加深我对此的理解，所以决定写这篇文章。本文主要梳理目前最新的 V16.4 的生命周期函数。现在 React 最新版本是 16.13，但是生命周期最新版本是 16.4，之后版本的生命周期没有过改动了，本文不涉及 Hooks。</p><a id="more"></a><p>先上示意图：</p><p><img src="https://i.loli.net/2020/06/27/aqjdmrcGHM8Fzx5.png" alt="React 生命周期示意图"></p><h2 id="废弃三个旧的生命周期函数"><a href="#废弃三个旧的生命周期函数" class="headerlink" title="废弃三个旧的生命周期函数"></a>废弃三个旧的生命周期函数</h2><p>React 在 V16.3 版本中，为下面三个生命周期函数加上了 <code>UNSAFE</code>：</p><ul><li><code>UNSAFE_componentWillMount</code></li><li><code>UNSAFE_componentWillReceiveProps</code></li><li><code>UNSAFE_componentWillUpdate</code></li></ul><p>标题中的废弃不是指真的废弃，只是不建议继续使用，并表示在 V17.0 版本中正式删除。先来说说 React 为什么要这么做。</p><p>主要是这些生命周期方法经常被误用和滥用。并且在 React V16.0 之前，React 是同步渲染的，而在 V16.0 之后 React 更新了其渲染机制，是通过异步的方式进行渲染的，在 <code>render</code> 函数之前的所有函数都有可能被执行多次。</p><p>长期以来，原有的生命周期函数总是会诱惑开发者在 <code>render</code> 之前的生命周期函数中做一些动作，现在这些动作还放在这些函数中的话，有可能会被调用多次，这肯定不是我们想要的结果。</p><h3 id="废弃-UNSAFE-componentWillMount-的原因"><a href="#废弃-UNSAFE-componentWillMount-的原因" class="headerlink" title="废弃 UNSAFE_componentWillMount 的原因"></a>废弃 UNSAFE_componentWillMount 的原因</h3><p>有一个常见的问题，有人问为什么不在 <code>UNSAFE_componentWillMount</code> 中写 AJAX 获取数据的功能，他们的观点是，<code>UNSAFE_componentWillMount</code> 在 <code>render</code> 之前执行，早一点执行早得到结果。但是要知道，在 <code>UNSAFE_componentWillMount</code> 中发起 AJAX 请求，不管多快得到结果也赶不上首次 render，数据都是要在 <code>render</code> 后才能到达。</p><p>而且 <code>UNSAFE_componentWillMount</code> 在服务器端渲染也会被调用到（此方法是服务端渲染唯一会调用的生命周期函数。），你肯定不希望 AJAX 请求被执行多次，所以这样的 IO 操作放在 <code>componentDidMount</code> 中更合适。</p><p>尤其是在 Fiber 启用了异步渲染之后，更没有理由在 <code>UNSAFE_componentWillMount</code> 中进行 AJAX 请求了，因为 <code>UNSAFE_componentWillMount</code> 可能会被调用多次，谁也不会希望无谓地多次调用 AJAX 吧。</p><p>还有人会将事件监听器（或订阅）添加到 <code>UNSAFE_componentWillMount</code> 中，但这可能导致服务器渲染（永远不会调用 <code>componentWillUnmount</code>）和异步渲染（在渲染完成之前可能被中断，导致不调用 <code>componentWillUnmount</code>）的内存泄漏。</p><p>人们通常认为 <code>UNSAFE_componentWillMount</code> 和 <code>componentWillUnmount</code> 是成对出现的，但这并不能保证。只有调用了 <code>componentDidMount</code> 之后，React 才能保证稍后调用 <code>componentWillUnmount</code> 进行清理。因此，添加监听器/订阅的推荐方法是使用 <code>componentDidMount</code> 生命周期。</p><h3 id="废弃-UNSAFE-componentWillReceiveProps-的原因"><a href="#废弃-UNSAFE-componentWillReceiveProps-的原因" class="headerlink" title="废弃 UNSAFE_componentWillReceiveProps 的原因"></a>废弃 UNSAFE_componentWillReceiveProps 的原因</h3><p>有时候组件在 <code>props</code> 发生变化时会产生副作用。与 <code>UNSAFE_componentWillUpdate</code> 类似，<code>UNSAFE_componentWillReceiveProps</code> 可能在一次更新中被多次调用。因此，避免在此方法中产生副作用非常重要。相反，应该使用 <code>componentDidUpdate</code>，因为它保证每次更新只调用一次。</p><p><code>UNSAFE_componentWillReceiveProps</code> 是考虑到因为父组件引发渲染可能要根据 <code>props</code> 更新 <code>state</code> 的需要而设立的。新的 <code>getDerivedStateFromProps</code> 实际上与 <code>componentDidUpdate</code> 一起取代了以前的 <code>UNSAFE_componentWillReceiveProps</code> 函数。</p><h3 id="废弃-UNSAFE-componentWillUpdate-的原因"><a href="#废弃-UNSAFE-componentWillUpdate-的原因" class="headerlink" title="废弃 UNSAFE_componentWillUpdate 的原因"></a>废弃 UNSAFE_componentWillUpdate 的原因</h3><p>有些人使用 <code>UNSAFE_componentWillUpdate</code> 是出于一种错误的担心，即当 <code>componentDidUpdate</code> 触发时，更新其他组件的 <code>state</code> 已经”太晚”了。事实并非如此。React 可确保在用户看到更新的 UI 之前，刷新在 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 期间发生的任何 <code>setState</code> 调用。</p><p>通常，最好避免这样的级联更新。当然在某些情况下，这些更新也是必需的（例如：如果你需要在测量渲染的 DOM 元素后，定位工具的提示）。不管怎样，在异步模式下使用 <code>UNSAFE_componentWillUpdate</code> 都是不安全的，因为外部回调可能会在一次更新中被多次调用。相反，应该使用 <code>componentDidUpdate</code> 生命周期，因为它保证每次更新只调用一次。</p><p>大多数开发者使用 <code>UNSAFE_componentWillUpdate</code> 的场景是配合 <code>componentDidUpdate</code>，分别获取 <code>rerender</code> 前后的视图状态，进行必要的处理。但随着 React 新的 <code>suspense</code>、<code>time slicing</code>、异步渲染等机制的到来，<code>render</code> 过程可以被分割成多次完成，还可以被暂停甚至回溯，这导致 <code>UNSAFE_componentWillUpdate</code> 和 <code>componentDidUpdate</code> 执行前后可能会间隔很长时间，足够使用户进行交互操作更改当前组件的状态，这样可能会导致难以追踪的 BUG。</p><p>React 新增的 <code>getSnapshotBeforeUpdate</code> 方法就是为了解决上述问题，因为 <code>getSnapshotBeforeUpdate</code> 方法是在 <code>UNSAFE_componentWillUpdate</code> 后（如果存在的话），在 React 真正更改 DOM 前调用的，它获取到组件状态信息更加可靠。</p><p>除此之外，<code>getSnapshotBeforeUpdate</code> 还有一个十分明显的好处：它调用的结果会作为第三个参数传入 <code>componentDidUpdate</code>，避免了 <code>UNSAFE_componentWillUpdate</code> 和 componentDidUpdate 配合使用时将组件临时的状态数据存在组件实例上浪费内存，<code>getSnapshotBeforeUpdate</code> 返回的数据在 <code>componentDidUpdate</code> 中用完即被销毁，效率更高。</p><p>更多问题详见：</p><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" title="异步渲染之更新 — React Docs" target="_blank" rel="noopener">异步渲染之更新 — React Docs</a></li><li><a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state" title="Update on Async Rendering — React Docs" target="_blank" rel="noopener">Update on Async Rendering — React Docs</a></li></ul><h2 id="新增两个生命周期函数"><a href="#新增两个生命周期函数" class="headerlink" title="新增两个生命周期函数"></a>新增两个生命周期函数</h2><p>React V16.3 中在废弃（这里的废弃不是指真的废弃，只是不建议继续使用，并表示在 V17.0 版本中正式删除）三个旧的生命周期函数的同时，React 还新增了两个生命周期函数：</p><ul><li><code>static getDerivedStateFromProps</code></li><li><code>getSnapshotBeforeUpdate</code></li></ul><p>在 React V16.3 版本中加入的 <code>static getDerivedStateFromProps</code> 生命周期函数存在一个问题，就是在生命周期的更新阶段只有在 <code>props</code> 发生变化的时候才会调用 <code>static getDerivedStateFromProps</code>，而在调用了 <code>setState</code> 和 <code>forceUpdate</code> 时则不会。</p><p>React 官方也发现了这个问题，并在 React V16.4 版本中进行了修复。也就是说在更新阶段中，接收到新的 <code>props</code>，调用了 <code>setState</code> 和 <code>forceUpdate</code> 时都会调用 <code>static getDerivedStateFromProps</code>。具体在下面讲到这个函数的时候有详细说明。</p><h2 id="React-生命周期梳理"><a href="#React-生命周期梳理" class="headerlink" title="React 生命周期梳理"></a>React 生命周期梳理</h2><p>React 生命周期主要分为三个阶段：</p><ul><li>挂载阶段</li><li>更新阶段</li><li>卸载阶段</li></ul><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p>挂载阶段也可以理解为初始化阶段，也就是把我们的组件插入到 DOM 中。这个阶段的过程如下：</p><ul><li><code>constructor</code></li><li><code>getDerivedStateFromProps</code></li><li><del><code>UNSAVE_componentWillMount</code></del></li><li><code>render</code></li><li>(React Updates DOM and refs)</li><li><code>componentDidMount</code></li></ul><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>组件的构造函数，第一个被执行。如果在组件中没有显示定义它，则会拥有一个默认的构造函数。如果我们显示定义构造函数，则必须在构造函数第一行执行 <code>super(props)</code>，否则我们无法在构造函数里拿到 this，这些都属于 ES6 的知识。</p><p>在构造函数中，我们一般会做两件事：</p><ul><li>初始化 <code>state</code></li><li>对自定义方法进行 <code>this</code> 的绑定</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      width,</span><br><span class="line">      height: <span class="string">'atuo'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange1 = <span class="keyword">this</span>.handleChange1.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleChange2 = <span class="keyword">this</span>.handleChange2.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><p>使用方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static getDerivedStateFromProps(nextProps, prevState)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">//根据 nextProps 和 prevState 计算出预期的状态改变，返回结果会被送给 setState</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的 <code>getDerivedStateFromProps</code> 是一个静态函数，所以不能在这函数里使用 <code>this</code>，简单来说就是一个纯函数。也表明了 React 团队想通过这种方式防止开发者滥用这个生命周期函数。每当父组件引发当前组件的渲染过程时，<code>getDerivedStateFromProps</code> 会被调用，这样我们有一个机会可以根据新的 <code>props</code> 和当前的 <code>state</code> 来调整新的 <code>state</code>。</p><p>这个函数会返回一个对象用来更新当前的 <code>state</code>，如果不需要更新可以返回 <code>null</code>。这个生命周期函数用得比较少，主要用于在重新渲染期间手动对滚动位置进行设置等场景中。该函数会在挂载时，在更新时接收到新的 <code>props</code>，调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。</p><p><img src="https://i.loli.net/2020/06/27/X2hI3j6PU5Df9pC.png" alt="getDerivedStateFromProps"></p><p>新的 <code>getDerivedStateFromProps</code> 实际上与 <code>componentDidUpdate</code> 一起取代了以前的 <code>UNSAFE_componentWillReceiveProps</code> 函数。<code>UNSAFE_componentWillReceiveProps</code> 也是考虑到因为父组件引发渲染可能要根据 <code>props</code> 更新 <code>state</code> 的需要而设立的。</p><h4 id="UNSAVE-componentWillMount"><a href="#UNSAVE-componentWillMount" class="headerlink" title="UNSAVE_componentWillMount"></a><del><code>UNSAVE_componentWillMount</code></del></h4><p><code>UNSAFE_componentWillMount()</code> 在挂载之前被调用。它在 <code>render()</code> 之前调用，因此在此方法中同步调用 <code>setState()</code> 不会触发额外渲染。通常，我们建议使用 <code>constructor()</code> 来初始化 <code>state。</code>避免在此方法中引入任何副作用或订阅。如遇此种情况，请改用 <code>componentDidMount()</code>。</p><p>此方法是服务端渲染唯一会调用的生命周期函数。<code>UNSAFE_componentWillMount()</code> 常用于当支持服务器渲染时，需要同步获取数据的场景。</p><h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>这是 React 中最核心的方法，class 组件中唯一必须实现的方法。</p><p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p><ul><li>原生的 DOM，如 div</li><li>React 组件</li><li>数组或 Fragment</li><li>Portals（插槽）</li><li>字符串和数字，被渲染成文本节点</li><li>Boolean 或 null，不会渲染任何东西</li></ul><p><code>render()</code> 函数应该是一个纯函数，里面只做一件事，就是返回需要渲染的东西，不应该包含其它的业务逻辑，如数据请求，对于这些业务逻辑请移到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 中。</p><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p><code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅</p><p>你可以在 <code>componentDidMount()</code> 里直接调用 <code>setState()</code>。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p><p>请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 <code>constructor()</code> 中初始化 <code>state</code>。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 <code>modals</code> 和 <code>tooltips</code> 等情况下，你可以使用此方式处理</p><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>更新阶段是指当组件的 props 发生了改变，或组件内部调用了 setState 或者发生了 forceUpdate，则进行更新。</p><p>这个阶段的过程如下：</p><ul><li><del><code>UNSAFE_componentWillReceiveProps</code></del></li><li><code>getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><del><code>UNSAFE_componentWillUpdate</code></del></li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate</code></li><li>(React Updates DOM and refs)</li><li><code>componentDidUpdate</code></li></ul><h4 id="UNSAFE-componentWillReceiveProps"><a href="#UNSAFE-componentWillReceiveProps" class="headerlink" title="UNSAFE_componentWillReceiveProps"></a><del><code>UNSAFE_componentWillReceiveProps</code></del></h4><p><code>UNSAFE_componentWillReceiveProps</code> 是考虑到因为父组件引发渲染可能要根据 <code>props</code> 更新 <code>state</code> 的需要而设立的。<code>UNSAFE_componentWillReceiveProps</code> 会在已挂载的组件接收新的 <code>props</code> 之前被调用。如果你需要更新状态以响应 <code>prop</code> 更改（例如，重置它），你可以比较 <code>this.props</code> 和 <code>nextProps</code> 并在此方法中使用 <code>this.setState()</code> 执行 <code>state</code> 转换。</p><p>如果父组件导致组件重新渲染，即使 <code>props</code> 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。在挂载过程中，React 不会针对初始 <code>props</code> 调用 <code>UNSAFE_componentWillReceiveProps()</code>。组件只会在组件的 <code>props</code> 更新时调用此方法。调用 <code>this.setState()</code> 通常不会触发 <code>UNSAFE_componentWillReceiveProps()</code>。</p><h4 id="getDerivedStateFromProps-1"><a href="#getDerivedStateFromProps-1" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><p>这个方法在挂载阶段已经讲过了，这里不再赘述。记住该函数会在挂载时，在更新时接收到新的 <code>props</code>，调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。它与 <code>componentDidUpdate</code> 一起取代了以前的 <code>UNSAFE_componentWillReceiveProps</code> 函数。</p><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有两个参数，根据此函数的返回值来判断是否进行重新渲染，<code>true</code> 表示重新渲染，<code>false</code> 表示不重新渲染，默认返回 <code>true</code>。注意，首次渲染或者当我们调用 <code>forceUpdate</code> 时并不会触发此方法。此方法仅用于性能优化。</p><p>因为默认是返回 <code>true</code>，也就是只要接收到新的属性和调用了 <code>setState</code> 都会触发重新的渲染，这会带来一定的性能问题，所以我们需要将 <code>this.props</code> 与 <code>nextProps</code> 以及 <code>this.state</code> 与 <code>nextState</code> 进行比较来决定是否返回 <code>false</code>，来减少重新渲染，以优化性能。请注意，返回 <code>false</code> 并不会阻止子组件在 <code>state</code> 更改时重新渲染。</p><p>但是官方提倡我们使用内置的 <code>PureComponent</code> 来减少重新渲染的次数，而不是手动编写 <code>shouldComponentUpdate</code> 代码。<code>PureComponent</code> 内部实现了对 props 和 <code>state</code> 进行浅层比较。</p><p>如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会调用 <code>UNSAFE_componentWillUpdate()</code>，<code>render()</code> 和 <code>componentDidUpdate()</code>。官方说在后续版本，React 可能会将 <code>shouldComponentUpdate</code> 视为提示而不是严格的指令，并且，当返回 <code>false</code> 时，仍可能导致组件重新渲染。</p><h4 id="UNSAFE-componentWillUpdate"><a href="#UNSAFE-componentWillUpdate" class="headerlink" title="UNSAFE_componentWillUpdate"></a><del><code>UNSAFE_componentWillUpdate</code></del></h4><p>当组件收到新的 <code>props</code> 或 <code>state</code> 时，会在渲染之前调用 <code>UNSAFE_componentWillUpdate()</code>。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。但是你不能此方法中调用 <code>this.setState()</code>。在 <code>UNSAFE_componentWillUpdate()</code> 返回之前，你也不应该执行任何其他操作（例如，<code>dispatch</code> Redux 的 <code>action</code>）触发对 React 组件的更新。</p><p>通常，此方法可以替换为 <code>componentDidUpdate()</code>。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 <code>getSnapshotBeforeUpdate()</code> 中。</p><h4 id="render-1"><a href="#render-1" class="headerlink" title="render"></a>render</h4><p>这个方法在挂载阶段已经讲过了，这里不再赘述。</p><h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 生命周期方法在 <code>render</code> 之后，在更新之前（如：更新 DOM 之前）被调用。给了一个机会去获取 DOM 信息，计算得到并返回一个 <code>snapshot</code>，这个 <code>snapshot</code> 会作为 <code>componentDidUpdate</code> 的第三个参数传入。如果你不想要返回值，请返回 <code>null</code>，不写的话控制台会有警告。</p><p>并且，这个方法一定要和 <code>componentDidUpdate</code> 一起使用，否则控制台也会有警告。<code>getSnapshotBeforeUpdate</code> 与 <code>componentDidUpdate</code> 一起，这个新的生命周期涵盖过时的 <code>UNSAFE_componentWillUpdate</code> 的所有用例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'#enter getSnapshotBeforeUpdate'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'#enter componentDidUpdate snapshot = '</span>, snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码可以看出来这个 <code>snapshot</code> 怎么个用法，<code>snapshot</code> 乍一看还以为是组件级别的某个“快照”，其实可以是任何值，到底怎么用完全看开发者自己，<code>getSnapshotBeforeUpdate</code> 把 <code>snapshot</code> 返回，然后 DOM 改变，然后 <code>snapshot</code> 传递给 <code>componentDidUpdate</code>。</p><p>官方给了一个例子，用 <code>getSnapshotBeforeUpdate</code> 来处理 <code>scroll</code>，并且说明了通常不需要这个函数，只有在重新渲染过程中手动保留滚动位置等情况下非常有用，所以大部分开发者都用不上，也就不要乱用。</p><h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。在这个函数里我们可以操作 DOM，和发起服务器请求，还可以 <code>setState</code>，但是注意一定要用 <code>if</code> 语句控制，否则会导致无限循环。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  <span class="comment">// 典型用法（不要忘记比较 props）：</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.userID !== prevProps.userID) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetchData(<span class="keyword">this</span>.props.userID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期，则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 <code>snapshot</code> 参数传递。否则此参数将为 undefined。</p><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>卸载阶段，这个阶段的生命周期函数只有一个：</p><h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。我们可以在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。注意不要在这个函数里调用 <code>setState()</code>，因为组件不会重新渲染了。</p><h3 id="其他不常用的生命周期函数"><a href="#其他不常用的生命周期函数" class="headerlink" title="其他不常用的生命周期函数"></a>其他不常用的生命周期函数</h3><p>还有两个很不常用的生命周期函数，在这也列一下。</p><p>详细使用示例请见：<a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror" title="React 官方文档" target="_blank" rel="noopener">React 官方文档</a></p><h4 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError()"></a>static getDerivedStateFromError()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此生命周期会在后代组件抛出错误后被调用。它将抛出的错误作为参数，并返回一个值以更新 <code>state</code>。<code>getDerivedStateFromError()</code> 会在渲染阶段调用，因此不允许出现副作用。如遇此类情况，请改用 <code>componentDidCatch()</code>。</p><h4 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此生命周期在后代组件抛出错误后被调用。它接收两个参数：</p><ol><li>error —— 抛出的错误。</li><li>info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。</li></ol><p><code>componentDidCatch()</code> 会在“提交”阶段被调用，因此允许执行副作用。它应该用于记录错误之类的情况：</p><p>如果发生错误，你可以通过调用 <code>setState</code> 使用 <code>componentDidCatch()</code> 渲染降级 UI，但在未来的版本中将不推荐这样做。可以使用静态 <code>getDerivedStateFromError()</code> 来处理降级渲染。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文参考了以下文章和官方文档，推荐阅读。</p><ul><li><a href="https://zh-hans.reactjs.org/docs/react-component.html" title="React.Component — React Docs" target="_blank" rel="noopener">React.Component — React Docs</a></li><li><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" title="异步渲染之更新 — React Docs" target="_blank" rel="noopener">异步渲染之更新 — React Docs</a></li><li><a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state" title="Update on Async Rendering — React Docs" target="_blank" rel="noopener">Update on Async Rendering — React Docs</a></li><li><a href="https://zhuanlan.zhihu.com/p/38030418" title="React v16.3 之后的组件生命周期函数" target="_blank" rel="noopener">React v16.3 之后的组件生命周期函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/42413419" title="谈谈 React 新的生命周期钩子" target="_blank" rel="noopener">谈谈 React 新的生命周期钩子</a></li><li><a href="https://juejin.im/post/5b6f1800f265da282d45a79a" title="我对 React v16.4 生命周期的理解" target="_blank" rel="noopener">我对 React v16.4 生命周期的理解</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有人会说，现在都 Hooks 一把梭了，你总结整合这些内容有啥用。其实学习这些内容，能够帮助你加深对 React 的理解，深入领会 React 的思想。并且，目前 Class component 与 Hooks 是并存的，虽然新项目一般都直接用 Hooks，但是老项目中难免会遇到 Class component，所以还是要学会的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上有很多关于 React 生命周期的文章，我也看了不少，为了梳理并加深我对此的理解，所以决定写这篇文章。本文主要梳理目前最新的 V16.4 的生命周期函数。现在 React 最新版本是 16.13，但是生命周期最新版本是 16.4，之后版本的生命周期没有过改动了，本文不涉及 Hooks。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://www.dingxuewen.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://www.dingxuewen.com/tags/JavaScript/"/>
    
      <category term="React" scheme="https://www.dingxuewen.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>初谈 CSS 预处理器</title>
    <link href="https://www.dingxuewen.com/article/introduction-to-css-preprocessor/"/>
    <id>https://www.dingxuewen.com/article/introduction-to-css-preprocessor/</id>
    <published>2020-06-14T08:00:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL（Domain Specific Language），来解决我们书写 CSS 时难以解决的问题：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li></ul><a id="more"></a><p>归结起来就是抽象能力。所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。</p><p>但是，CSS 预处理器也不是万金油，CSS 的好处在于简便、随时随地被使用和调试。预编译 CSS 步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。所以在使用 CSS 预处理器时，要注意避免出现此类问题。</p><p>Sass 中变量以 $ 打头比较不容易和 CSS 标准语法冲突。Less 中变量则以 @ 打头，虽说容易和后续规范更新的新语法冲突，但是理论上只要 CSS 规范不引入 <code>@a: b</code> 这样的规则，问题也不大。而且规范制定的时候也会参考很多现有的实现。</p><p>Sass 和 Less 的变量机制有很大的不同，Sass 是类似 JS 的块级作用域一样，可以在作用域内重新赋值而不影响外部，Less 是以全局的最后一次赋值为准。SASS 和 SCSS 只是两种语法风格而已，SCSS 更贴近 CSS 语法，前端写起来更舒服。Less 和 Sass 最常用的部分并没有明显的区别，不用太在意该用哪个，Just pick one。至于公司用哪个，跟着用就行，不出大问题不用考虑换。</p><h2 id="CSS-预处理器可以为我们提供以下“超能力”"><a href="#CSS-预处理器可以为我们提供以下“超能力”" class="headerlink" title="CSS 预处理器可以为我们提供以下“超能力”"></a>CSS 预处理器可以为我们提供以下“超能力”</h2><p>下文复制自 <a href="https://github.com/cssmagic/blog/issues/73" target="_blank" rel="noopener">浅谈 CSS 预处理器（一）：为什么要使用预处理器？</a>，文中的示例代码均采用 Stylus 作为 CSS 预处理语言。</p><h3 id="文件切分"><a href="#文件切分" class="headerlink" title="文件切分"></a>文件切分</h3><p>页面越来越复杂，需要加载的 CSS 文件也越来越大，我们有必要把大文件切分开来，否则难以维护。传统的 CSS 文件切分方案基本上就是 CSS 原生的 <code>@import</code> 指令，或在 HTML 中加载多个 CSS 文件，这些方案通常不能满足性能要求。</p><p>CSS 预处理器扩展了 <code>@import</code> 指令的能力，通过编译环节将切分后的文件重新合并为一个大文件。这一方面解决了大文件不便维护的问题，另一方面也解决了一堆小文件在加载时的性能问题。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>把文件切分的思路再向前推进一步，就是“模块化”。一个大的 CSS 文件在合理切分之后，所产生的这些小文件的相互关系应该是一个树形结构。</p><p>树形的根结节一般称作“入口文件”，树形的其它节点一般称作“模块文件”。入口文件通常会依赖多个模块文件，各个模块文件也可能会依赖其它更末端的模块，从而构成整个树形。</p><p>以下是一个简单的示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry.less</span><br><span class="line"> ├─ base.less</span><br><span class="line"> │   ├─ normalize.less</span><br><span class="line"> │   └─ reset.less</span><br><span class="line"> ├─ layout.less</span><br><span class="line"> │   ├─ header.less</span><br><span class="line"> │   │   └─ nav.less</span><br><span class="line"> │   └─ footer.less</span><br><span class="line"> ├─ section-foo.less</span><br><span class="line"> ├─ section-bar.less</span><br><span class="line"> └─ ...</span><br></pre></td></tr></table></figure><p>入口文件 <code>entry.less</code> 在编译时会引入所需的模块，生成 entry.css，然后被页面引用。</p><p>如果你用过其它拥有模块机制的编程语言，应该已经深有体会，模块化是一种非常好的代码组织方式，是开发者设计代码结构的重要手段。模块可以很清晰地实现代码的分层、复用和依赖管理，让 CSS 的开发过程也能享受到现代程序开发的便利。</p><h3 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h3><p>选择符嵌套是文件内部的代码组织方式，它可以让一系列相关的规则呈现出层级关系。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在变更出现之前，CSS 中的所有属性值都是“幻数”。你不知道这个值是怎么来的、它的什么样的意义。有了变量之后，我们就可以给这些“幻数”起个名字了，便于记忆、阅读和理解。</p><p>接下来我们会发现，当某个特定的值在多处用到时，变量就是一种简单而有效的抽象方式，可以把这种重复消灭掉，让你的代码更加 DRY。</p><p>变量让开发者更容易实现网站视觉风格的统一，也让“换肤”这样的需求变得更加轻松易行。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>光有变量还是不够的，我们还需要有运算。如果说变量让值有了意义，那么运算则可以让值和值建立关联。有些属性的值其实跟其它属性的值是紧密相关的，CSS 语法无法表达这层关系；而在预处理语言中，我们可以用变量和表达式来呈现这种关系。</p><p>举个例子，我们需要让一个容器最多只显示三行文字，在以前我们通常是这样写的：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line"><span class="attribute">overflow-y</span>: hidden;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">4.5em</span>;  <span class="comment">/* = 1.5 x 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以发现，我们只能用注释来表达 <code>max-height</code> 的值是怎么来的，而且注释中 <code>3</code> 这样的值也是幻数，还需要进一步解释。未来当行高或行数发生变化的时候，<code>max-height</code> 的值和注释中的算式也需要同步更新，维护起来很不方便。</p><p>接下来我们用预处理语言来改良一下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span></span><br><span class="line">$max-lines = 3</span><br><span class="line">$line-height = 1.5</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">overflow-y</span>: <span class="selector-tag">hidden</span></span><br><span class="line">line-height: $line-height</span><br><span class="line">max-height: unit($line-height * $max-lines, 'em')</span><br></pre></td></tr></table></figure><p>乍一看，代码行数似乎变多了，但代码的意图却更加清楚了——不需要任何注释就把整件事情说清楚了。在后期维护时，只要修改那两个变量就可以了。</p><p>值得一提的是，这种写法还带来另一个好处。<code>$line-height</code> 这个变量可以是 <code>.wrapper</code> 自己定义的局部变量（比如上面那段代码），也可以从更上层的作用域获取：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$line-height = 1.5  // 全局统一行高</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span></span><br><span class="line">line-height: $line-height</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span></span><br><span class="line">$max-lines = 3</span><br><span class="line"></span><br><span class="line">max-height: unit($line-height * $max-lines, 'em')</span><br><span class="line"><span class="selector-tag">overflow-y</span>: <span class="selector-tag">hidden</span></span><br></pre></td></tr></table></figure><p>这意味着 <code>.wrapper</code> 可以向祖先继承行高，而不需要为这个“只显示三行”的需求把自己的行高写死。有了运算，我们就有能力表达属性与属性之间的关联，它令我们的代码更加灵活、更加 DRY。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>把常用的运算操作抽象出来，我们就得到了函数。</p><p>开发者可以自定义函数，预处理器自己也内置了大量的函数。最常用的内置函数应该就是颜色的运算函数了吧！有了它们，我们甚至都不需要打开 Photoshop 来调色，就可以得到某个颜色的同色系变种了。</p><p>举个例子，我们要给一个按钮添加鼠标悬停效果，而最简单的悬停效果就是让按钮的颜色加深一些。我们写出的 CSS 代码可能是这样的：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#ff4466</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#f57900</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我相信即使是最资深的视觉设计师，也很难分清 <code>#ff4466</code> 和 <code>#f57900</code> 这两种颜色到底有什么关联。而如果我们的代码是用预处理语言来写的，那事情就直观多了：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span></span><br><span class="line">$color = #ff9833</span><br><span class="line"></span><br><span class="line">background-color: $color</span><br><span class="line">&amp;<span class="selector-pseudo">:hover</span></span><br><span class="line">background-color: darken($color, 20%)</span><br></pre></td></tr></table></figure><p>此外，预处理器的函数往往还支持默认参数、具名实参、<code>arguments</code> 对象等高级功能，内部还可以设置条件分支，可以满足复杂的逻辑需求。</p><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>Mixin 是 CSS 预处理器提供的又一项实用功能。Mixin 的形态和用法跟函数十分类似——先定义，然后在需要的地方调用，在调用时可以接受参数。它与函数的不同之处在于，函数用于产生一个值，而 Mixin 的作用是产生一段 CSS 代码。</p><p>Mixin 可以产生多条 CSS 规则，也可以只产生一些 CSS 声明。</p><p>一般来说，Mixin 可以把 CSS 文件中类似的代码块抽象出来，并给它一个直观的名字。比如 CSS 框架可以把一些常用的代码片断包装为 mixin 备用，在内部按需调用，或暴露给使用者在业务层调用。</p><p>举个例子，我们经常会用到 clearfix 来闭合浮动。在原生 CSS 中，如果要避免 clearfix 代码的重复，往往只能先定义好一个 <code>.clearfix</code> 类，然后在 HTML 中挂载到需要的元素身上：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为 clearfix 定义一个类 */</span></span><br><span class="line">.clearfix &#123;...&#125;</span><br><span class="line">.clearfix::after &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 挂载到这两个元素身上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info clearfix"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把表现层的实现暴露到了结构层，是不是很不爽？而在预处理器中，我们还可以选择另一种重用方式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 为 clearfix 定义一个 mixin</span><br><span class="line"><span class="selector-tag">clearfix</span>()</span><br><span class="line">    ...</span><br><span class="line">    &amp;<span class="selector-pseudo">::after</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">// 在需要的元素身上调用</span><br><span class="line"><span class="selector-class">.info</span></span><br><span class="line">    <span class="selector-tag">clearfix</span>()</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span></span><br><span class="line">    <span class="selector-tag">clearfix</span>()</span><br></pre></td></tr></table></figure><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p>CSS 预处理语言无法直接运行于浏览器环境，这意味着我们编写的源码需要编译为 CSS 代码之后才能用于网页。这似乎是一个门槛，需要我们付出“额外”的成本。</p><p>但在目前的大环境下，大多数项目的前端开发流程已经包含了构建环节，比如选择任何一个脚本模块化方案都是需要在部署时走一道打包程序的。所以对大多数团队来说，这个门槛其实已经跨过去一大半了。</p><p>而一旦接受了这种设定，我们还可以享受到“额外”的福利。在给 CSS 的开发加入编译环节的同时，还可以顺道加入其它构建环节，比如代码校验、代码压缩、代码后处理等等。</p><p>“代码后处理”是指 PostCSS 平台上各类插件所提供的功能，光是 Autoprefixer 这一项就已经值回票价了。我们再也不需要在 CSS 代码中手工添加浏览器前缀了，直接使用标准写法，剩下的事情让工具搞定吧！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>本文中大部分内容直接复制整合了参考资料中的内容，因为这些文章写的很好，没必要再用自己的话复述，因此取长补短，进行了整合，版权归原作者所有。</p></blockquote><ul><li><a href="https://github.com/cssmagic/blog/issues/73" target="_blank" rel="noopener">浅谈 CSS 预处理器（一）：为什么要使用预处理器？</a></li><li><a href="https://efe.baidu.com/blog/revisiting-css-preprocessors/" target="_blank" rel="noopener">再谈 CSS 预处理器 - Baidu EFE</a></li><li><a href="https://v.youku.com/v_show/id_XMTMwODk2MDkyNA==.html" target="_blank" rel="noopener">CSS预处理器 - 郑海波</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL（Domain Specific Language），来解决我们书写 CSS 时难以解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；&lt;/li&gt;
&lt;li&gt;没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://www.dingxuewen.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS" scheme="https://www.dingxuewen.com/tags/CSS/"/>
    
      <category term="Sass" scheme="https://www.dingxuewen.com/tags/Sass/"/>
    
      <category term="Scss" scheme="https://www.dingxuewen.com/tags/Scss/"/>
    
      <category term="Less" scheme="https://www.dingxuewen.com/tags/Less/"/>
    
      <category term="JavaScript" scheme="https://www.dingxuewen.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React 之我见：JSX，虚拟 DOM，Diff 算法，setState，state 和 props 梳理</title>
    <link href="https://www.dingxuewen.com/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/"/>
    <id>https://www.dingxuewen.com/article/react-in-my-mind-jsx-virtual-dom-diff-setstate/</id>
    <published>2020-05-27T12:10:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要梳理一下我对 React 框架基础内容的认识，之后也会总结一些深度内容的认识。当然，笔者水平也有限，如果你发现不妥之处，望斧正！</p><a id="more"></a><h2 id="为什么要用-React-等前端框架"><a href="#为什么要用-React-等前端框架" class="headerlink" title="为什么要用 React 等前端框架"></a>为什么要用 React 等前端框架</h2><p>因为可以进行组件化开发？社区强大？使用的人多？有很多好用的第三方库和插件？适用于单页面应用开发？这些都不是最本质的原因。</p><p><strong>最本质的原因是保持 UI 和状态同步并不容易。</strong></p><p>使用原生 JavaScript 编写代码的时候，一般静态内容是在 HTML 中创建，动态内容使用 JavaScript 创建。但是使用 JavaScript 构建 UI 代码量巨大，并且可读性不高，代码可复用性也差。</p><p>更重要的是，如果我们想要保持 UI 和状态的同步应该怎么做？例如，我们有一个列表，我们需要实现将列表与服务器同步的功能。我们需要将本地数据和服务器发来的数据进行比较。并且需要点对点的将每个变更同步到 DOM 节点中。如果这个过程中有每一步出现差错都直接导致 UI 同步失败。因此，维护 UI 与数据同步需要编写大量繁琐，脆弱和脆弱的代码。</p><p>为了解决以上问题，降低开发成本，前端社区出现了 React 等框架。到目前为止，这些框架提供的最大的改进是实现应用状态和 UI 同步。我们只需要定义一次 UI，不必为每一次动作都编写 UI。相同的状态总能得到相同的 UI 输出，即状态和 UI 同步，状态变更后会自动更新 UI。</p><blockquote><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/39852035" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39852035</a></p></blockquote><h2 id="React-VS-Vue"><a href="#React-VS-Vue" class="headerlink" title="React VS Vue"></a>React VS Vue</h2><p>很多人都说 React 上手要难一些，Vue 上手要简单一些。也有很多人在问 React 和 Vue 的区别是什么。我想说一下我的理解。</p><p>首先，在框架设计层面，React 是 MVC 软件架构中的 View，它只负责视图层的东西，而对于数据和路由等，则由 Redux 和 Router 等来完成。这也就是为什么 React 官方文档说 “React 是一个用于构建用户界面的 JavaScript 库”。而 Vue 则不同，Vue 是基于 MVVM 架构设计的一个框架，所以在架构层面，Vue 和 React 的思想就是不同的。</p><p>React 的设计哲学很简单，不可变（Immutable）思想贯穿了整个框架的设计。React 可以说没引进什么新的概念，让开发者能够以类似写原生 JavaScript 代码的方式来使用 React 进行开发。这也就是很多人说 React 难的原因，即 JavaScript 基础知识。</p><p>而很多人说 Vue 容易上手，可能有些同学就迷惑了，我觉得 Vue 不简单啊。笔者认为，说 Vue 简单是因为 Vue 将很多底层逻辑封装好了，直接给你对应的 API，你调用对应 API 就可以完成对应的工作。所以，你不需要有很扎实的 JavaScript 基础，你只要记住或者能够查阅到对应 API 就可以用 Vue 完成一些基础性的开发。所以有些后端的同学可以看看 Vue 官方文档就能上手基础的前端开发。</p><p>React 之我见，那一定要说我的看法，我喜欢 React。我喜欢其简洁的设计理念和类原生的开发体验，让我能够感觉到自己是在写代码。那么 Vue 我没有深入学习，但这是一个非常优秀的前端框架，目前也已经安排进了下一阶段的学习任务中。</p><h2 id="React-JSX，虚拟-DOM-和-ReactDOM-render"><a href="#React-JSX，虚拟-DOM-和-ReactDOM-render" class="headerlink" title="React JSX，虚拟 DOM 和 ReactDOM.render"></a>React JSX，虚拟 DOM 和 ReactDOM.render</h2><h3 id="JSX-和虚拟-DOM"><a href="#JSX-和虚拟-DOM" class="headerlink" title="JSX 和虚拟 DOM"></a>JSX 和虚拟 DOM</h3><p>JSX 和虚拟 DOM 是必说内容。JSX 也就是 JavaScript 的一个语法扩展，可以通过 Babel 对 JSX 进行转译。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>例如这样一段 JSX 代码会被 Babel 转译成：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = React.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;,</span><br><span class="line">    <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>从这里我们可以看出，<code>React.createElement</code> 方法的参数是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createElement( tag, attrs, child1, child2, child3 );</span><br></pre></td></tr></table></figure><p>那么我们可以实现一下 <code>createElement</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params"> tag, attrs, ...children </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        tag,</span><br><span class="line">        attrs,</span><br><span class="line">        children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这样就可以对其进行调用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将上文定义的 createElement 方法放到对象 React 中</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">    createElement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        hello&lt;span&gt;world!&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log( element );</span><br></pre></td></tr></table></figure><blockquote><p>此处引用 <a href="https://github.com/hujiulong" target="_blank" rel="noopener">hujiulong</a> 的 <a href="https://github.com/hujiulong/blog/issues/4" target="_blank" rel="noopener">从零开始实现一个 React（一）：JSX 和虚拟 DOM</a>，详细内容推荐看其原文。</p></blockquote><p>也就是说，<code>createElement</code> 方法返回的东西就是所谓的虚拟 DOM。说到虚拟 DOM 就必说 diff 算法，这个我们之后再讲。</p><h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><p><code>render</code> 其实没有太多好说的，其作用就是将虚拟 DOM 渲染成真实的 DOM，只是在实现的过程中有非常多的细节情况要处理。</p><h2 id="React-组件和生命周期"><a href="#React-组件和生命周期" class="headerlink" title="React 组件和生命周期"></a>React 组件和生命周期</h2><p>在 React 中，我们可以通过 Class 和 Function 两种方式来写组件。以 Class 的方式写组件的时候，我们需要继承 React.Component。这里主要涉及 React.Component 的模拟实现和 React 的生命周期。模拟实现推荐看 <a href="https://github.com/hujiulong/blog/issues/5" target="_blank" rel="noopener">从零开始实现一个 React（二）：组件和生命周期</a>。至于 React 的生命周期，之后我会总结一篇文章，推荐大家去看 React 官方文档。</p><h2 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h2><p>为什么要 diff？因为 DOM 操作十分昂贵，也就是非常耗时耗性能。但是 DOM 操作就一定很慢很耗性能吗？其实不一定，只是普遍来讲是这样的，详细内容推荐看 JJC 的知乎回答：<a href="https://www.zhihu.com/question/324992717/answer/707044362" target="_blank" rel="noopener">前端为什么操作 DOM 是最耗性能的呢</a>。简单讲，浏览器中 DOM 对象是使用 C++ 开发的，性能肯定不慢，有些情况下性能甚至高于操作 JavaScript 对象。而大多数时候操作 DOM 是很耗性能的，这是因为 JavaScript 对象的属性（properties）映射到的是 DOM 对象的特性（attributes）上。</p><p>我们操作 JavaScript 对象只是修改一个对象，而修改 DOM 对象时还会修改对象的 attributes，那么性能就消耗在 JavaScript 对象和 DOM 对象的转换和同步上。并且，操作 DOM 还会影响页面的渲染，进而会再一次降低了性能。虽然 DOM 的性能有可能比操作普通对象还要快，但 99% 的场景下，操作 DOM 对象还是昂贵的。所以，高效的 diff 势在必行。</p><p>我们可以通过实现高效的 diff 算法，对比出操作前后有差异的 DOM 节点，然后只对更改了的 DOM 进行更新。这样可以大大减少没有必要的 DOM 操作，进而大幅提升性能。</p><p>React 的 diff 算法其实很简单：对比当前真实 DOM 和虚拟 DOM，在对比过程中直接更新真实 DOM。并且这个比对是同级比对，当发现这一级的 DOM 不同时，会直接更新该节点及其所有子节点。这种 diff 策略实际上是出于性能上的取舍。首先，DOM 操作很少出现跨层级的情况，所以只需要同级比对就可以满足大多数情况，也就没有必要对比所有的 DOM 节点，因为那样需要 O(n^3) 的时间复杂度，代价太高。</p><p>React 虚拟 DOM 的 Diff 原理的思维导图如下所示：</p><p><img src="https://i.loli.net/2020/06/27/Z1JR8hy7KEGsiLz.png" alt="React Virtual Dom Diff Algorithm"></p><p>React diff 算法的模拟实现推荐参见：<a href="https://github.com/hujiulong/blog/issues/6" target="_blank" rel="noopener">从零开始实现一个 React（三）：Diff 算法</a></p><h2 id="所谓异步的-setState"><a href="#所谓异步的-setState" class="headerlink" title="所谓异步的 setState"></a>所谓异步的 setState</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>首先明确，所谓异步的 setState 并不是真的异步，只是其行为类似于异步操作的行为。下面我们来详细说说。</p><p>首先，将 setState 的行为设置为所谓异步的形式的出发点依旧是性能优化，因为如果每次通过 setState 更改了状态都对组件进行一次更新，会很浪费性能。而通过将多次 setState 合并在一起，进行一次更新渲染，则会大大提升性能。</p><p>将多个 setState 的调用合并成一个来执行，也就意味着 state 并不会被立即更新。例如下面这例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            num: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState( &#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125; );</span><br><span class="line">            <span class="built_in">console</span>.log( <span class="keyword">this</span>.state.num );    <span class="comment">// 会输出什么？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">                &lt;h1&gt;&#123; <span class="keyword">this</span>.state.num &#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个组件 <code>APP</code>，在组件挂载后，会循环 100 次。但当我们真的对这个组件进行渲染会发现，渲染结果为 1，并且控制台中输出了 100 次 0。也就是说，每次循环中拿到的 state 都还是更新之前的。也就是说 React 对 setState 进行了优化，但如果我们就是想要立刻获得更新后的 state 怎么办呢？React 提供了一种解决方案，setState 接收的参数还可以是一个函数，通过这个函数我们可以拿到更新之前的状态，然后通过这个函数的返回值得到下一个状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState( <span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log( prevState.num );</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                num: prevState.num + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并-setState"><a href="#合并-setState" class="headerlink" title="合并 setState"></a>合并 setState</h3><p>对于这个地方，有两个要点：一是如何对多个 setState 调用进行合并。二是我怎么判定一次合并哪些 setState 呢？接下来我们一一解答。</p><p>setState 的合并是通过队列实现的。通过创建一个队列来保存每次 setState 的数据，然后每隔一段时间，清空和这个队列并渲染组件。此处的模拟实现推荐阅读：<a href="https://github.com/hujiulong/blog/issues/7" target="_blank" rel="noopener">从零开始实现一个 React（四）：异步的 setState</a></p><p>接下来就是一次到底合并哪些 setState。换句话说，我们会将一段时间内的 setState 调用合并成在一起执行，那么这段时间的长短取决于什么？其实此处使用的是 JavaScript 的事件队列机制，也就是事件循环（Event Loop）。关于事件循环的详细内容可参见阮一峰的 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈 Event Loop</a>。事件循环的核心概念就是同步任务，异步任务，微任务以及宏任务。</p><p>在 React 的 setState 中，利用 JavaScript 的事件循环机制对多个 setState 调用进行合并。首先创建一个队列保存每次 setState 的数据，在一次事件循环的所有同步任务之后，清空队列，将队列中的所有 setState 进行合并，并进行一次性更新渲染。这样在一次事件循环的，最多只会执行一次合并操作，并且只会渲染一次组件。</p><p>所以呢，这也就是为什么我说，所谓的 setState 的异步行为并不是真正的异步，只是不会对每一个 setState 操作进行实时更新，而是通过队列的方式对一次事件循环中的所有同步任务的 setState 调用进行合并，合并成一个之后进行一次更新和渲染，所以效果上看上去是异步的，但并不是 setTimeout 或 setInterval 这种真正的异步操作。</p><h3 id="关于-setState-同步异步的总结"><a href="#关于-setState-同步异步的总结" class="headerlink" title="关于 setState 同步异步的总结"></a>关于 setState 同步异步的总结</h3><ol><li><p>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</p></li><li><p>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。</p></li><li><p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p></li></ol><p>参考文章：<a href="https://juejin.im/post/5b45c57c51882519790c7441" target="_blank" rel="noopener">https://juejin.im/post/5b45c57c51882519790c7441</a></p><h2 id="React-中-props-和-state-的关系"><a href="#React-中-props-和-state-的关系" class="headerlink" title="React 中 props 和 state 的关系"></a>React 中 props 和 state 的关系</h2><p>React 中的 props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的几个重要的不同点就是：</p><p>props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p><p>props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 由于 props 是传入的，并且它们不能更改，因此我们可以将任何仅使用 props 的 React 组件视为 pureComponent，也就是说，在相同的输入下，它将始终呈现相同的输出。</p><p>state 是在组件中创建的，一般在 constructor 中初始化 state。state 是多变的、可以修改，一般通过 setState 被修改，并且一般是异步更新的。</p><p>至此，React 的基本概念已经梳理完毕，感谢阅读。笔者水平有限，如果你发现任何问题，欢迎评论指正！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">React Dosc</a></li><li><a href="https://zh-hans.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">React 官方文档</a></li><li><a href="https://github.com/hujiulong/blog/issues/4" target="_blank" rel="noopener">从零开始实现一个 React（一）：JSX和虚拟DOM</a></li><li><a href="https://github.com/hujiulong/blog/issues/5" target="_blank" rel="noopener">从零开始实现一个 React（二）：组件和生命周期</a></li><li><a href="https://github.com/hujiulong/blog/issues/6" target="_blank" rel="noopener">从零开始实现一个 React（三）：Diff 算法</a></li><li><a href="https://github.com/hujiulong/blog/issues/7" target="_blank" rel="noopener">从零开始实现一个 React（四）：异步的 setState</a></li><li><a href="https://www.zhihu.com/question/324992717/answer/707044362" target="_blank" rel="noopener">前端为什么操作 DOM 是最耗性能的呢 —— JJC 的知乎回答</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要梳理一下我对 React 框架基础内容的认识，之后也会总结一些深度内容的认识。当然，笔者水平也有限，如果你发现不妥之处，望斧正！&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://www.dingxuewen.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://www.dingxuewen.com/tags/JavaScript/"/>
    
      <category term="React" scheme="https://www.dingxuewen.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Iterable，Iterator，Generator 三者的区别与联系</title>
    <link href="https://www.dingxuewen.com/article/iterable-iterator-and-generator-of-javascript/"/>
    <id>https://www.dingxuewen.com/article/iterable-iterator-and-generator-of-javascript/</id>
    <published>2020-02-26T09:23:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，我们经常会看到可迭代对象，迭代器和生成器的概念，它们之间有什么区别和联系呢，我就是想通过这篇文章总结一下，把这个问题搞明白。</p><a id="more"></a><h2 id="Interable（可迭代对象）"><a href="#Interable（可迭代对象）" class="headerlink" title="Interable（可迭代对象）"></a>Interable（可迭代对象）</h2><p>Iterable 是指有 <code>[Symbol.iterator]</code> 属性的对象，这个属性 <code>obj[Symbol.iterator]</code> 就是 Iterator（迭代器）。也可以说可迭代对象是实现了 <code>Symbol.iterator</code> 方法的对象。</p><p>可迭代对象可以被 <code>for..of</code> 循环遍历，我们最常进行迭代操作的可迭代对象就是 Array，其实还有其他可迭代对象，例如 String、Set、Map、函数的 arguments 对象和 NodeList 对象等，这些对象都有默认的 <code>Symbol.iterator</code> 属性。</p><h2 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h2><p>Iterator 必须有 <code>next()</code> 方法，它每次返回一个 <code>{done: Boolean, value: any}</code> 对象，这里 <code>done:true</code> 表明迭代结束，否则 <code>value</code> 就是下一个要迭代的值。</p><h3 id="手写实现一个-Iterator"><a href="#手写实现一个-Iterator" class="headerlink" title="手写实现一个 Iterator"></a>手写实现一个 Iterator</h3><p>假设我们 <code>range</code> 对象，我们希望对其使用 <code>for..of</code> 循环：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们希望可以这样：</span></span><br><span class="line"><span class="comment">// for(let num of range) ... num=1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>为了让 <code>range</code> 对象可迭代，我们需要为对象添加一个名为 <code>Symbol.iterator</code> 的方法。当 <code>for..of</code> 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 迭代器（iterator） —— 一个有 next 方法的对象。从此开始，<code>for..of</code> 仅适用于这个被返回的对象。当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法。<code>next()</code> 方法返回的结果的格式必须是 <code>{done: Boolean, value: any}</code>，当 <code>done=true</code> 时，表示迭代结束，否则 <code>value</code> 是下一个值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for..of 循环首先会调用这个</span></span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 它返回迭代器对象，接下来 for..of 仅与此迭代器一起工作</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    current: <span class="keyword">this</span>.from,</span><br><span class="line">    last: <span class="keyword">this</span>.to,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next() 在 for..of 的每一轮循环迭代中被调用</span></span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="comment">// 它将会返回 &#123;done:.., value :...&#125; 格式的对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.current &lt;= <span class="keyword">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="keyword">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在它可以运行了！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意可迭代对象的核心功能：关注点分离。<code>range</code> 自身没有 <code>next()</code> 方法。相反，是通过调用 <code>range[Symbol.iterator]()</code> 创建了另一个对象，即所谓的“迭代器”对象，并且它的 <code>next</code> 会为迭代生成值。因此，迭代器对象和与其进行迭代的对象是分开的。</p><p>从技术上说，我们可以将它们合并，并使用 <code>range</code> 自身作为迭代器来简化代码。</p><p>就像这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">this</span>.current = <span class="keyword">this</span>.from;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.current &lt;= <span class="keyword">this</span>.to) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="keyword">this</span>.current++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>range[Symbol.iterator]()</code> 返回的是 <code>range</code> 对象自身：它包括了必需的 <code>next()</code> 方法，并通过 <code>this.current</code> 记忆了当前的迭代进程。这样更短，对吗？是的。有时这样也可以。</p><p>但缺点是，现在不可能同时在对象上运行两个 <code>for..of</code> 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 <code>for..of</code> 是很罕见的，即使在异步情况下。</p><h3 id="无穷迭-Interator"><a href="#无穷迭-Interator" class="headerlink" title="无穷迭 Interator"></a>无穷迭 Interator</h3><p>此外，我们还可以将 <code>range</code> 设置为 <code>range.to = Infinity</code>，这时 <code>range</code> 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。<code>next</code> 没有什么限制，它可以返回越来越多的值，这是正常的。当然，迭代这种对象的 <code>for..of</code> 循环将不会停止。但是我们可以通过使用 <code>break</code> 来停止它。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 是一个特殊函数，调用返回一个 Generator。</p><p>未完待续……</p><p><strong>参考：</strong></p><ul><li><a href="https://zh.javascript.info/iterable" target="_blank" rel="noopener">Iterables（可迭代对象）</a></li><li><a href="https://github.com/coconilu/Blog/issues/73" target="_blank" rel="noopener">JS 可迭代对象、迭代器、生成器</a></li><li><a href="https://segmentfault.com/a/1190000016824284" target="_blank" rel="noopener">ES6 迭代器与可迭代对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中，我们经常会看到可迭代对象，迭代器和生成器的概念，它们之间有什么区别和联系呢，我就是想通过这篇文章总结一下，把这个问题搞明白。&lt;/p&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://www.dingxuewen.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaScript" scheme="https://www.dingxuewen.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何在 5 分钟 PPT 汇报中迅速抓住评委眼球</title>
    <link href="https://www.dingxuewen.com/article/how-to-quickly-attract-judges-in-a-5-minute-ppt-report/"/>
    <id>https://www.dingxuewen.com/article/how-to-quickly-attract-judges-in-a-5-minute-ppt-report/</id>
    <published>2019-06-16T14:15:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，我认为自己的 PPT 汇报能力还可以，在经历过的那么多大大小小的答辩和汇报中积累了一些经验。这一次答辩，让我看到了我需要继续改进的方向。</p><a id="more"></a><p>6 月 13 号，作为从 2018 年 09 月工作至现在的学生兼职辅导员，需要参加学校组织的评优答辩，我自认为准备的还不错。是的，我在时间把控上可以做到，5 分钟的汇报，我能把控在 4:55-5:00 之间完成。在进行答辩准备的时候，我也有想过评委到底想看到什么，但是想的还不够，其实是很不够。</p><p>本次参加答辩的，全校共有 14 名学生兼辅，评委共六名。答辩结束后，学工部副部长把同学们留了下来，可以说是给同学们上了“一堂课”。一直以来我对这种领导并没有什么好感，但是这一次，这一位，真的让我感觉是一位实干的领导，干练、直接、讲真话，让我由衷的佩服。</p><p>本文主要记录如何在时间很短的 PPT 汇报中，迅速抓住评委的“心”。本文以兼职辅导员工作汇报为例，但其实其他工作汇报、学习进展汇报、学术汇报、晋升汇报等都是相通的。</p><h2 id="技巧方法"><a href="#技巧方法" class="headerlink" title="技巧方法"></a>技巧方法</h2><p>在这么短的时间里，想要把方方面面都介绍到是不可能的。那你就要想，如何能够迅速抓住评委的“心”。首先思考评委最想看到什么？最不想看到什么？以兼职辅导员工作汇报为例，评委最想看到的就是你的工作成果，工作亮点。最不想看到的就是流水账式的工作记录汇报。</p><ol><li><p><strong>介绍自己：</strong>大部分的汇报，你都需要先把自己是谁介绍清楚，根据不同的汇报主题有所侧重。例如进行兼职辅导员汇报，你就需要介绍自己以往相关工作经历，并重点介绍担任兼职辅导员期间的学习成绩，将自己与评委的关注点相匹配。在取得丰硕工作成果的同时，能够取得优异的成绩，能够证明你的学习能力强，协调能力强，自律性强等等。</p></li><li><p><strong>工作成果：</strong>这是证明你工作能力和工作效果最好的证明。</p></li><li><p><strong>工作亮点：</strong>你是如何取得的工作成果，通过什么工作方法，有什么工作亮点。</p></li><li><p><strong>数字量化：</strong>使用数字量化你的工作量和工作成果，简单直观，当然也需要你真的有足够的工作付出，以及能拿得出手的工作成果。</p></li><li><p><strong>举例证要谨慎：</strong>举例证一定要谨慎，举正面例证，千万不要给自己挖坑。以兼职辅导员工作汇报为例，举早操相关的例证就是给自己挖坑，因为这两部分工作一直做的都不够好。早操的初衷是让大家早点起床早锻炼，而现在成了强迫大家早起的手段。迟到、旷到、无精打采等现象很普遍。并且目前早操后会进行早读，这也不是早操的初衷，目前只是没办法，食堂位子不够，只能通过早读进行分流，错开学生就餐时间。</p></li><li><p><strong>图片要精选：</strong>图片不是用来证明你做过某项工作，而是用来点睛的。图片要能突出亮点，有特色，能“打动人”。</p></li><li><p><strong>紧扣核心主题：</strong>针对各个分要点进行介绍，最后一定要点题。本次汇报是什么主题，核心内容是什么。例如兼职辅导员工作，核心是人的引领。辅导员是思政教师，无论你的日常工作多么繁杂，一定要展现思想上的引领，紧扣主题。</p></li></ol><p>以上就是本次分享的一些 PPT 汇报技巧，希望对你有用。</p><p>后记：其实这一年的兼职辅导员工作也挺有意思的，恰逢学校本研一体化改革以及新校区建设，学校史无前例的人员调动，使得工作上情况更复杂。最后，也很感谢学院和学校能给我这样一个担任兼职辅导员的机会，是我有幸有这样一段工作体验，祝大家今后顺利。</p><p>至此，以为记。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话，我认为自己的 PPT 汇报能力还可以，在经历过的那么多大大小小的答辩和汇报中积累了一些经验。这一次答辩，让我看到了我需要继续改进的方向。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="https://www.dingxuewen.com/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工作技巧" scheme="https://www.dingxuewen.com/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="PPT" scheme="https://www.dingxuewen.com/tags/PPT/"/>
    
  </entry>
  
  <entry>
    <title>你真的知道怎么写文案吗 —《文案训练手册》</title>
    <link href="https://www.dingxuewen.com/article/do-you-really-know-how-to-write-a-good-copy/"/>
    <id>https://www.dingxuewen.com/article/do-you-really-know-how-to-write-a-good-copy/</id>
    <published>2019-06-09T23:30:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享的书是《文案训练手册》，作者是约瑟夫 · 休格曼。全书共分四部分，第一部分写的是文案写作的一些基本概念，并归纳为 15 条公理。第二部分写的是撰写文案的技巧，包括 23 个文案元素和 31 条心理诱因。第三部分是结合一些文案实例，进行具体分析。第四部分介绍了各种不同媒介与平面广告的不同之处，以及为不同媒介写文案时的注意事项。</p><a id="more"></a><img width="40%" src="https://i.loli.net/2019/06/15/5d045852ea22822825.png"><p><strong><center>2019 年第 03 本书</center></strong></p><p><strong>推荐读者：</strong>想学习如何撰写文案，想了解什么样的文案吸引人，为什么吸引人，想扩大知识面的人。也推荐给所有喜欢写文字的人，写文字其实就是一种表达，传递信息以达到目的，很多写广告文案的技巧，会对你写文章有帮助。</p><p>首先明确一点，文案的最终目的就是让你心甘情愿地花钱买产品或服务。作者认为平面广告是直销广告中最难写的广告之一，你只能通过纸上的文字，没有声音和其他信息，并需要吸引读者阅读广告并购买产品。因此，写文案需要有好的创意，而创意来自于经历。在学习写文案时，要锻炼自己的发散思维能力，也就是将各种毫无关联的概念联系子一起的能力。</p><p>在你开始为一个产品写文案前，你需要有足够的专业知识，足够了解你的顾客和产品的本质。挖掘产品的本质，提取顾客感兴趣的要素，发布广告后静待效果。切记文案中勿用恐吓的方式。</p><h3 id="一、文案写作公理"><a href="#一、文案写作公理" class="headerlink" title="一、文案写作公理"></a>一、文案写作公理</h3><ol><li><strong>公理一：</strong>文案写作是一段精神旅程，是对你全部的经历、专业知识以及以卖产品或服务为目的，对这些信息进行精神加工，将其形成文字的能力的体现。</li><li><strong>公理二：</strong>一则广告里的所有元素，首先都只有一个目的，即吸引读者阅读文案的第一句话。</li><li><strong>公理三：</strong>文案的第一句话要简短易读，第一句话的目的是吸引读者阅读第二句话，以此类推。</li><li><strong>公理四：</strong>广告的版面设计和广告的前几个段落必须创造舒适的购买环境，调动目标客户的购买欲。例如打折促销则使用大字体标注价格，体现热闹。昂贵的产品则在广告设计时注意档次和精致。</li><li><strong>公理五：</strong>创造购买环境 👉 获取目标客户注意 👉 自我介绍。为了营造和谐的开场，必须通过问答引导使目标客户开始说“是”，在表达时要表现的诚恳，值得信赖。让读者说“是”，让他们在阅读文案时，与你产生共鸣。</li><li><strong>公理六：</strong>好的文案应该能让人一读到底，停不下来，这就是所谓的滑梯效应。</li><li><strong>公理七：</strong>打破思维定式，多发散思维。</li><li><strong>公理八：</strong>种下好奇的种子，使文案趣味横生。可以使用“接下来我会更深入地讲解”、“所以请勿离开”、“为什么我不在这结尾”、“请听我的解释、“下面才是真正精彩的部分”等表达方式设置悬念。</li><li><strong>公理九：</strong>推销概念，而不要推销产品。将产品融入概念，价格也可以影响概念。</li><li><strong>公理十：</strong>酝酿过程就是你的潜意识运用你的知识和经历来解决一个具体问题，其效率由时间、创意倾向、环境和自尊心决定。<ul><li>将手头关于该产品的材料都浏览一遍，提想法，写思考。</li><li>去玩儿，不再想文案，此时你的潜意识其实一直在工作。</li><li>等酝酿出好的创意就抓紧写出来，酝酿过程中时间、自尊心等会给你一定的压力，加快酝酿的过程。</li></ul></li><li><strong>公理十一：</strong>你不可能通过文案告诉目标客户足够多他们感兴趣的内容。文案应该长到足以引导读者按照你的要求去做。使用长文案有两个基本原因：一是你要有足够的内容营造舒适的购买环境，引导读者购买。二是你要有足够长的内容讲述产品的各个方面。</li><li><strong>公理十二：</strong>通过合适的署名方式，合适的词语和人称营造私人化的沟通。使用“我”和“你”第一人称，营造具有私人情感到沟通。</li><li><strong>公理十三：</strong>文案中提出的创意需要以一种有条理的方式贯通起来，预测用户的问题，然后进行回答，就像面对面一样。</li><li><strong>公理十四：</strong>编辑过程是对初稿的后续加工，精炼文案，用最少的字表达诉求。</li><li><strong>公理十五：</strong>将产品定位从防治型转向治愈型，因为销售治愈型产品更容易。</li><li><strong>附加一：</strong>写文案的时候不要担心初稿很烂，有想法就写出来。</li><li><strong>附加二：</strong>用情感的表达方式引人入胜，而不是列生硬的技术指标。<ul><li>原则 1：每一个词都蕴含感情，讲述一个故事。</li><li>原则 2：好广告都是词语、感受和印象的情感流露。</li><li>原则 3：以感情来卖产品，以理性来诠释购买。</li></ul></li></ol><h3 id="二、广告中平面元素的作用"><a href="#二、广告中平面元素的作用" class="headerlink" title="二、广告中平面元素的作用"></a>二、广告中平面元素的作用</h3><ol><li><strong>标题：</strong>获取你的注意，引领你去看副标题。</li><li><strong>副标题：</strong>给你更多的信息，进一步解释抓住了你眼球的标题。</li><li><strong>照片或图画：</strong>获取注意力，全面说明产品。</li><li><strong>图片说明：</strong>照片或者图画的文字说明，这部分不可获取，读者经常会阅读。</li><li><strong>文案：</strong>传达有关产品或服务的主要销售信息。</li><li><strong>段落标题：</strong>对文案进行划分，减少阅读的压迫感。</li><li><strong>商标：</strong>展示销售该产品的公司的名字。</li><li><strong>价格：</strong>让读者知道他需要花多少钱，价格的字体应该大一些，否则会被淹没在文案中。</li><li><strong>反馈方式：</strong>通常在广告结尾部分放置使用优惠券、免费电话或订购信息的方式，给读者提供一种对广告的反馈途径。</li><li><strong>整体设计：</strong>通过对其他元素进行有效的平面设计，呈现出广告的整体面貌。</li></ol><h3 id="三、撰写文案时需要考虑的-23-个文案元素"><a href="#三、撰写文案时需要考虑的-23-个文案元素" class="headerlink" title="三、撰写文案时需要考虑的 23 个文案元素"></a>三、撰写文案时需要考虑的 23 个文案元素</h3><ol><li><strong>字体：</strong>由个性，有感情，清晰度和辨识度高，传达公司的形象。</li><li><strong>第一句话：</strong>简短易读，足够说服人，能让读者继续阅读第二句话。</li><li><strong>第二句话：</strong>保持读者兴趣，继续读下去。</li><li><strong>段落标题：</strong>用于分割文案，降低阅读压迫性，引起读者好奇心。可以是介绍后面段落内容，也可以毫无关系。</li><li><strong>产品说明：</strong>复杂的产品简单讲，简单的产品复杂讲。</li><li><strong>新特性：</strong>揭示出产品的特性，与市面上其他产品的异同。</li><li><strong>技术说明：</strong>通过适当的技术性说明，体现可靠性，增加信任度。</li><li><strong>预测异议：</strong>预测读者的异议，并在文案中主动指出。</li><li><strong>解决异议：</strong>提出异议的解决方案，打消顾客疑虑。</li><li><strong>性别：</strong>了解目标受众，用合适且尊重的语言沟通。</li><li><strong>清晰性：</strong>清楚、简单、短小且直中要害。</li><li><strong>陈词滥调：</strong>避免废话。</li><li><strong>节奏：</strong>注意节奏感，增加趣味性，文案读起来抑扬顿挫。</li><li><strong>服务：</strong>对昂贵或不方便退货的产品，强调服务便利性，以打消顾客顾虑。</li><li><strong>物理性质：</strong>文案中提及产品所有的物理性质，满足顾客的需求。</li><li><strong>试用期：</strong>提供足够长的试用期，打消顾虑，增加信心，提升好感度。</li><li><strong>价格比较：</strong>精确地对比价格，以帮助顾客衡量价值。对比要公平，否则会惹官司。</li><li><strong>代言：</strong>找匹配度高的代言人，提升产品和服务可信度。</li><li><strong>价格：</strong>用黑体（也就是强调）标示，或标注在优惠券中。便宜则突出，昂贵则低调处理。</li><li><strong>要有总结：</strong>总结为顾客提供的东西。</li><li><strong>避免拖泥带水：</strong>文案要简洁，只留下必要的内容。</li><li><strong>订购便捷：</strong>有虚线分隔的优惠券，免费电话和可撕下的名片等。</li><li><strong>请求购买：</strong>在文案结尾附近，请求顾客购买，以巩固文案的效果。</li></ol><h3 id="四、平面广告的-31-个心理诱因"><a href="#四、平面广告的-31-个心理诱因" class="headerlink" title="四、平面广告的 31 个心理诱因"></a>四、平面广告的 31 个心理诱因</h3><ol><li>让顾客有参与感，拥有感。</li><li>诚实：真实地表述产品优缺点，以建立信任。</li><li>正直：与诚实相同。</li><li>信用：提高可信度。</li><li>证明产品的价值。</li><li>使购买合理化：给出购买的理由。</li><li>贪婪：利用好这个人性弱点。</li><li>建立权威：让消费者买得放心。</li><li>满意度保证：提供足够的消费者保障。</li><li>产品的本质：挖掘并展示产品独特的本质。</li><li>客户的本质：了解并满足客户的核心需求。</li><li>符合当前的时尚潮流。</li><li>时机：通过测试等方法选择合适的时机。</li><li>建立联系：将销售的产品或服务，与客户很容易辨识的东西联系在一起。</li><li>一致性：第一级推销要简单，一旦顾客买了，可以随后追加销售。购买的方法要简单、小巧、并和目标客户的需求一致。</li><li>符合客户的需求：先满足市场需求以积累资本。</li><li>归属感：营造归属感，让顾客为了归属一个群体而购买，时尚、品味、精致和文化等。</li><li>收藏冲动：包装产品，让顾客有收藏冲动。</li><li>好奇心：制造好奇心，让顾客购买。</li><li>营造紧迫感。</li><li>恐惧：有一部分紧迫感就是建立在恐惧之上的。</li><li>瞬间满足：以更快的速度满足顾客需求，当日达、次日达快递就属于这种。</li><li>独有、珍贵或特别。</li><li>简单：广告文案简单，产品定位简单，不要给客户太多选择。</li><li>人际关系：用人性化的词，与顾客产生共鸣。</li><li>讲故事：吸引读者，引发好奇心。</li><li>精神投入：注意描述方式，给读者留下思考和想象空间，以给予其成就感。</li><li>内疚感：给顾客提供服务，让他产生不购买就会内疚的感觉。</li><li>具体：该具体的部分要具体，体现自己是这方面的专家，增加可信度。</li><li>熟悉：多次发布广告，提升熟悉感，包括品牌和购物环境。</li><li>希望：给予顾客希望，注意培养可信度。例如买了我的产品可以变漂亮、可以提高智商等。</li></ol><h3 id="五、写文案的-7-个步骤"><a href="#五、写文案的-7-个步骤" class="headerlink" title="五、写文案的 7 个步骤"></a>五、写文案的 7 个步骤</h3><ol><li>深入了解产品或服务</li><li>了解目标客户</li><li>写下标题和副标题</li><li>撰写文案</li><li>编辑文案</li><li>停止编辑，开始酝酿</li><li>修改 👉 酝酿 👉 修改循环 ♻️，满意为止。</li></ol><h3 id="六、不同媒介的特点和文案撰写要点"><a href="#六、不同媒介的特点和文案撰写要点" class="headerlink" title="六、不同媒介的特点和文案撰写要点"></a>六、不同媒介的特点和文案撰写要点</h3><ol><li>型录：文案和图片都扮演了重要角色的广告形式，型录的封面放置最吸引人的图片，最具代表性的产品。<ul><li>型录前面包含总裁致辞，并附上照片。致辞私人化，型录形象化，真实化，人性化。让型录不是冰冷的手册，而是真实可接触的。</li><li>型录应该包含产品所有突出特征，所有信息。</li><li>通过图片和外观创造氛围，要迎合消费层次，是促销还是高档等。</li><li>每一页都有免费购买电话，又大又醒目，方便订购。还可以附加网购链接。</li><li>确保订购表填写简单，并提供充裕的空间方便其填写。</li></ul></li><li>传单：插入页、回执、阔幅说明书<ul><li>这些都是售后广告，可能是包括在售的其他产品，也可以是特别设计的型录。</li><li>要有抓人眼球的标题，并附有订购信息。</li></ul></li><li>直邮：个性化、营造私人关系和信任，可以使用直接给一个人写信的口吻，而不是群发。<ul><li>信末的附言阅读率很高，在这可以重申要点等，以促使读者购买。</li><li>邮件名单要精准，信封就相当于标题，打开信封就像阅读副标题。</li><li>可以不把名字或者标题放在信封，以让收件人在好奇心的促使下打开信封。</li></ul></li><li>报纸：<ul><li>用迎合大众的方式，不同层次的报纸对应不同层次的人群，需要用不同的方式。</li><li>合适的投放频率，不会立刻见效。</li><li>日报话题生命力为几天，周报为十天左右，考虑投放频率。</li></ul></li><li>户外广告牌：需要语言强有力，创造冲动。独立的标题，最多再有一个很短的副标题，需要有图，需要精彩创意，并且简洁。</li><li>新闻稿：<ul><li>开头具备尽可能多的细节，给出新闻的六要素：时间、地点、任务、起因、经过和结果。</li><li>引用专家、名人对产品或服务的评价。</li><li>将产品或服务与当下最热门的话题/事件联系起来。</li></ul></li><li>广播电台：鼓励听众的想象力。<ul><li>重视投放频率和时段的选择。</li><li>要及时将核心信息传达给听众</li><li>广播是线性方式听取信息。</li><li>电话等订购方式相关信息必须好记。</li><li>插播广告的开头具有决定性意义，好奇的诱因做开头不错，例如说：我有一些重要的信息提供给 XXX。</li></ul></li><li>电视购物：<ul><li>产品价格决定是否适合这种广告形式，作者认为便宜的商品更适合。</li><li>包装产品，让其看上去很完美。</li><li>让产品简单，不给客户太多选择。</li><li>利用紧迫感，让观众马上购买，例如优惠只有最后 20 分钟。</li><li>包括网页，二维码等，满足不同客户需求。</li><li>产品要大众化，因为电视受众很大众化。</li></ul></li><li>专题广告片：现在不是很适用。</li><li>延伸性销售</li><li>售后推销</li><li>家庭购物，例如美国 QVC 网站。</li><li>互联网：在网上视觉传达很重要，互联网测试花销更少，更便捷。提出一个想法可以迅速低成本执行。吸引目标用户的方式有邮件、网站主页、电子型录、博客、电子杂志、营销长信、视频、链接和搜索引擎优化等。</li><li>电子邮件传播：<ul><li>保持简短，用接收者的名字，并签署自己的名字营造个人化信件。</li><li>邮件主题行简短，要么让收件人能立刻认出是谁发的，要么就写上他感兴趣的内容。</li><li>分享有价值的内容，让其养成打开邮件的习惯，并建立信任，培养和提供价值。</li><li>可以通过线下活动等，用免费的东西吊胃口，获取邮件等信息，之后用于推销。</li></ul></li><li>互联网长信：<ul><li>自始至终都需要把“立刻购买”按钮呈现在屏幕醒目位置。</li><li>段落标题做链接，使之能直接链接到订购页。</li><li>长信可以不局限于声音和视频，还可以录制真人示范，但是要说话自然且颜值要高。</li><li>将老板招聘放入长信，增加信任感，让客户感觉是在和人打交道。</li><li>把有趣的信息提供给正在渴望的人，那么长短则无所谓。</li></ul></li><li>互联网专题页：<ul><li>产品越贵，专题页越长越详细。</li><li>订购方式简单。</li><li>处理好注意力跨度，保持节目有趣，节奏快，比电视广告专题片要短。</li><li>可以通过音视频进行增售，也要列出免费电话，供给需要的人。</li></ul></li><li>图书的推广：<ul><li>写文案炒作，促销，炒出畅销书。</li><li>在发行前一周创建网站，网上预售，提供免费礼品，但是需要顾客提供一些个人信息。</li></ul></li><li>博客：SEO，写名人，追热点。</li><li>病毒营销</li><li>网店：购买流程要简单，送货要快，记录整理好客户的联系方式，以后可以给他们发带有链接的促销信息。</li><li>未来的互联网相关营销途径。</li></ol><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>这本书分享了很多作者撰写文案的经验，并且结合具体实例进行了分析，对帮助了解如何撰写文案，什么样的文案吸引人，为什么吸引人等很有用。这本书的翻译一般，翻译腔比较浓，并且由于书的年代、技术的发展和国情等的不同，有些内容不太适用，但是总体是很有价值的，推荐阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享的书是《文案训练手册》，作者是约瑟夫 · 休格曼。全书共分四部分，第一部分写的是文案写作的一些基本概念，并归纳为 15 条公理。第二部分写的是撰写文案的技巧，包括 23 个文案元素和 31 条心理诱因。第三部分是结合一些文案实例，进行具体分析。第四部分介绍了各种不同媒介与平面广告的不同之处，以及为不同媒介写文案时的注意事项。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.dingxuewen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="多抓鱼" scheme="https://www.dingxuewen.com/tags/%E5%A4%9A%E6%8A%93%E9%B1%BC/"/>
    
      <category term="文案" scheme="https://www.dingxuewen.com/tags/%E6%96%87%E6%A1%88/"/>
    
      <category term="管理" scheme="https://www.dingxuewen.com/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="营销" scheme="https://www.dingxuewen.com/tags/%E8%90%A5%E9%94%80/"/>
    
  </entry>
  
  <entry>
    <title>群体心理学的开山之作 —《乌合之众》</title>
    <link href="https://www.dingxuewen.com/article/the-crowd-a-study-of-the-popular-mind/"/>
    <id>https://www.dingxuewen.com/article/the-crowd-a-study-of-the-popular-mind/</id>
    <published>2019-05-20T00:04:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享的书是《乌合之众》，作者是居斯塔夫 · 勒庞。这本书原名是《群体心理学》（Psychologie des foules），英文版改作《大众心理研究》（A Study of the Popular Mind）。并加了一个主书名（The Crowd），中文版则译为《乌合之众》。</p><a id="more"></a><p>全书共分为三卷，卷一讲群体的心理，包括群体的特征和精神统一率，群体的情感与道德，群体的观念、推理和想象力，群体的所有信仰都是宗教形式。卷二讲群体的主张与信念，包括群体信念与主张之间的间接因素，群体主张的直接因素，群体领袖及其说服别人的方式，群体信念与主张的变化范围。卷三先讲述了群体的分类和特点，并结合犯罪群体、法庭陪审团、选民群体和议会群体进行实例分析。这本书读起来并不轻松，但是内容非常值得你细细品味，如果遇到读不懂的地方，可以多读几遍。</p><img width="40%" src="https://i.loli.net/2019/06/15/5d044a82b1fb997625.png"><p><strong><center>2019 年第 02 本书</center></strong></p><p><strong>推荐读者：</strong>对群体行为和群体心理感兴趣的人，如果你之前没有读过相关的书，相信这本书的内容会让你有较大的收获。</p><h2 id="一、群体的概念"><a href="#一、群体的概念" class="headerlink" title="一、群体的概念"></a>一、群体的概念</h2><p>《乌合之众》中的群体指的是受某一事件、演说、激情、恐惧、爱恨的刺激而聚集在一起，为某个目标或某些精神需求而有所行动的一个特殊的心理群体。</p><p>勒庞在本书中所说的”群体“与弗洛伊德笔下的”流氓“是完全不一样的。弗洛伊德笔下的”流氓“总是服从于同一个领袖，而勒庞所指的”群体“只在某一激情燃烧或者事件发生的时间段内服从于某一领袖，当促使他们聚集成群的刺激物消失时，他们也就不再听从这个领袖了。</p><h3 id="群体精神统一规律"><a href="#群体精神统一规律" class="headerlink" title="群体精神统一规律"></a>群体精神统一规律</h3><p>人一旦加入群体，原来的个性便会消失，不再独立思考而随大流，无意识占领上风，智力程度减弱。群体中的个人具有独处时所没有的特点，这就是勒庞所说的“群体精神统一规律”，也就是群体的精神灵魂。一个人独处时可能是个很有教养的人，但加入群体后的他可以变成凶残、易怒且充满暴力的野蛮人。</p><p>群体心理的诞生就像化学反应，没有因素的总和或平均，只有像化学反应那样的新特征的组合和创造。群体心理形成后，群体便会获得某些普遍的特征，这些特征虽然短暂但极其明确。</p><p>出现这种情况的主要原因有以下四点：</p><ol><li>力大无穷的幻觉：加入群体后，由于人多势众，个人会产生一种力大无穷的幻觉，感觉自己不可战胜，什么都可以做到；</li><li>法不责众：因人数众多，知道自己无论做什么坏事都不会遭到惩罚，而束缚个人行为的责任感一消失，人便会所心所欲，肆意妄为；</li><li>传染性：群体具有很强的传染性，一传十，十传百。这决定了群体会变现出什么特点，有什么取向；</li><li>容易接受暗示：这决定了群体中的个人有时会呈现出与他独处时完全相反的特性。</li></ol><h2 id="二、群体的特点"><a href="#二、群体的特点" class="headerlink" title="二、群体的特点"></a>二、群体的特点</h2><p>群体没有主见，缺乏头脑，常被人利用充当炮灰。同时群体很暴力很危险，极具破坏性，甚至常常犯罪。</p><h3 id="1-群体行为无意识，冲动，多变，易怒，易受外界干扰"><a href="#1-群体行为无意识，冲动，多变，易怒，易受外界干扰" class="headerlink" title="1. 群体行为无意识，冲动，多变，易怒，易受外界干扰"></a>1. 群体行为无意识，冲动，多变，易怒，易受外界干扰</h3><p>群体的行为完全是无意识的，只服从自己的冲动，很容易受到外界刺激因素和一时激情的影响，情绪变幻无常，思想和愿望都不持久。作者表示，群体的这种无意识可能就是群体力量强大的秘密之一。</p><h3 id="2-群体不理性，缺乏判断力和批评精神，易受暗示，轻信"><a href="#2-群体不理性，缺乏判断力和批评精神，易受暗示，轻信" class="headerlink" title="2. 群体不理性，缺乏判断力和批评精神，易受暗示，轻信"></a>2. 群体不理性，缺乏判断力和批评精神，易受暗示，轻信</h3><p>由于群体不讲理性，做事不经过大脑，缺乏判断力和批评精神，所以显得极其轻信。对他们来说，没有什么是不可能的。而群体不懂思考，所以暗示给群体的不管是什么观念，只有在形式变得绝对和简单的时候才能被群体理解和接纳。</p><h3 id="3-感情夸大化，简单化，不懂怀疑和犹豫，易走极端"><a href="#3-感情夸大化，简单化，不懂怀疑和犹豫，易走极端" class="headerlink" title="3. 感情夸大化，简单化，不懂怀疑和犹豫，易走极端"></a>3. 感情夸大化，简单化，不懂怀疑和犹豫，易走极端</h3><p>感情和思想的简单化和夸大化使他们既不懂得怀疑，也不会犹豫，动不动就走极端，极易做出很坏的事情。群体常常服从低劣的本能，有时也可以作为品德高尚和道德崇高的典范。</p><h3 id="4-情绪和行为具感染性，易被误导"><a href="#4-情绪和行为具感染性，易被误导" class="headerlink" title="4. 情绪和行为具感染性，易被误导"></a>4. 情绪和行为具感染性，易被误导</h3><p>群体中任何情绪和行为都具有感染性，很容易受别人的意见和主张影响，使得群体中的个人都有很强的从众心理，容易被人误导。集体观察是错误率最高的，它往往只是某个人的幻觉，通过传染，暗示给别人。说某事是成千人同时看见的，这往往意味着事实真相与人们所说的大相径庭。</p><h3 id="5-喜欢幻觉不喜欢真理，推理能力差"><a href="#5-喜欢幻觉不喜欢真理，推理能力差" class="headerlink" title="5. 喜欢幻觉不喜欢真理，推理能力差"></a>5. 喜欢幻觉不喜欢真理，推理能力差</h3><p>群体喜欢幻觉而不喜欢真理，推理能力差，根本就不可能理解系统的逻辑推理，不会推理或者总是错误地推理。</p><h3 id="6-易受传统影响，保守，奴性，害怕改变"><a href="#6-易受传统影响，保守，奴性，害怕改变" class="headerlink" title="6. 易受传统影响，保守，奴性，害怕改变"></a>6. 易受传统影响，保守，奴性，害怕改变</h3><p>容易受到古老世袭制的影响，保守，奴性，忠君守旧，害怕改变。群体的笃信具有宗教感情固有的特点：盲目服从，极其褊狭，渴望传播。</p><p>崇拜心目中的崇高者，害怕他身上所谓的神奇力量，盲目地服从命令，缺乏分析这些信条的能力，只想着传播它们。所有不接受这些信条的人都有可能被当作敌人。对群体来说，必须有个神，否则什么都谈不上。</p><h3 id="7-行动能力强"><a href="#7-行动能力强" class="headerlink" title="7. 行动能力强"></a>7. 行动能力强</h3><p>受到暗示的群体，可以随时为了暗示给他们的理想而赴汤蹈火。并且彻底摧毁过于残旧的文明是群体最明确的任务。</p><p>综上所述，对于群体来说，真正正确的观念并不一定起作用，只有通过各种方式成为无意识，并成为一种情感才能真正起作用。但是使新观念进入人们大脑的过程非常漫长，但是一旦进入，想要排出它也需要同样长的时间。所以，就观念而言，群体总是落后学者和哲学家好几代人。</p><h2 id="三、群体的分类"><a href="#三、群体的分类" class="headerlink" title="三、群体的分类"></a>三、群体的分类</h2><p>群体主要分为异质性群体和同质性群体两类。</p><h3 id="1-异质性群体："><a href="#1-异质性群体：" class="headerlink" title="1. 异质性群体："></a>1. 异质性群体：</h3><p>A． 无名称（比如街头人群）<br>B． 有名称（陪审团、议会等）</p><h3 id="2-同质性群体"><a href="#2-同质性群体" class="headerlink" title="2. 同质性群体"></a>2. 同质性群体</h3><p>A． 派别（政治派别、宗教派别等）<br>B． 身份团体（军人、僧侣、工人等）<br>C． 阶级（资产阶级、农民阶级等）</p><h2 id="四、群体的主张与信念"><a href="#四、群体的主张与信念" class="headerlink" title="四、群体的主张与信念"></a>四、群体的主张与信念</h2><p>群体的信念与主张的间接因素包括种族、传统、时间、制度和教育。</p><p>例如，同样的制度在一些国家非常适用，而在另一些国家则完全相反。这其实和制度没有关系，而是种族和传统等因素造成了这种差异。</p><p>群体主张的直接因素包括形象、词汇、套话、幻觉、经验和理性。群体对形象很敏感，群里最喜欢形象化的事物，并且群体的想象力是极其丰富的，想象力丰富也就使得群体很容易通过想象而产生各种幻觉。此外，群体不喜欢长篇大论，更喜欢浓缩的词汇和套话，简单易懂就好。</p><p>群体的领袖一般分为两类，第一类粗暴、胆大、勇敢，第二类意志持久，尽管看起来没有第一类那么神气，但是影响要大得多，因为更符合群体的喜好。</p><p>想要领导群体，要做到断言、重复和传染，并且要有足够的声望。断言就是说断就断，说话做决定要果断。重复就是将断言重复到一定的次数，就可以获得大家的认可。对于保持声望，想要得到群众的敬仰，那就要永远与他们保持距离，保留神秘感和威严感。</p><h2 id="五、内容引申"><a href="#五、内容引申" class="headerlink" title="五、内容引申"></a>五、内容引申</h2><p>每一种文明都有自己的规则，有纪律，有远见，有文化，是从本能过渡到理性的结果。历史上的大动荡往往都来自于基本观念的变化。</p><p>本书中提到了两个例子，很值得细细品味。一个是高等教育和职业教育相关的例子，一个是立法者加税的例子。</p><p>第一个例子是在教育方面，如果想稳固阶级，最重要的是职业教育。因为社会对高等教育人才的需求是有限的，如果过多的人接受了高等教育，而对这类人才的需求没有跟上，则会出现很多毕业生找不到工作（其实是对工作更挑剔），而很多岗位招不到人的状况，这就会影响社会的稳定。这里明白的人可以细品一下，我就不过多展开了。</p><p>第二个例子是立法者加税，立法者想增加一个税种，不会选择理论上最正确的税种。 群体接受的是表面上看起来正确的选择，而不是理论上正确的。 所以，间接税不管多么过分，总是能被民众所接受，因为每天几分钱的消费税，不影响他们的生活，不会引起注意。</p><p>如果我们代之以按工资或其他收入比例来纳税，要一次付清，即便理论上比别的税轻十倍，也会引起一致的反对。 要在规定的日期缴纳，数额相对就较大，看起来很多，因此也比较惊人。一点点支付，税才不会显得太重。然而，这种节约手段需要一定的远见，这是群体所缺乏的。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本书细致地考察了群体的一般性心理特征，对群体的道德观、情感、想象力和信念等诸多方面进行了探讨，指出个人进入群体之后容易丧失自我意识，在群体意识的压迫下成为盲目、冲动、狂热、轻信的“乌合之众”的一员。并且指出，影响大众想象力的不是事实本身，而是它的扩散和传播方式。</p><p>本书的意义在于，首次阐明了社会心理学中的一些重要问题；研究了群体特征和种族特征的不同之处；指出了群众运动的性质；分析了领袖与群众、民主与独裁的关系。</p><p>此外，本书也体现出了作者勒庞的一些局限性。例如歧视女性和拉丁民族，部分研究不够系统和深刻，观点有些片面，时有臆断和偏见甚至矛盾；作者是站在领英的立场上思考和行文，而非普通群众。</p><p>当然，瑕不掩瑜，依旧是一本值得细细品味的好书。本期好书导读至此结束，敬请期待下期分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享的书是《乌合之众》，作者是居斯塔夫 · 勒庞。这本书原名是《群体心理学》（Psychologie des foules），英文版改作《大众心理研究》（A Study of the Popular Mind）。并加了一个主书名（The Crowd），中文版则译为《乌合之众》。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.dingxuewen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微信读书" scheme="https://www.dingxuewen.com/tags/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="心理学" scheme="https://www.dingxuewen.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何从零开始入门互联网行业 —《全栈市场人》</title>
    <link href="https://www.dingxuewen.com/article/how-to-get-started-from-scratch-to-enter-the-internet-industry/"/>
    <id>https://www.dingxuewen.com/article/how-to-get-started-from-scratch-to-enter-the-internet-industry/</id>
    <published>2019-01-29T13:30:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享的书是《全栈市场人》，作者是 Lydia。本书出版于 2017 年 02 月，全书共有七章，包括互联网基础知识、互联网市场人、运营人所需要的软硬技能、网感的养成、市场人的工作内容介绍、教你玩转自媒体，以及作者的个人工作经验分享。</p><a id="more"></a><p>这本书讲的内容比较简单，通俗易懂，<strong>作者以很聊天式的方式，为你描述了什么是互联网市场营销，什么是运营。帮你了解互联网，帮你成为一名合格的互联网人。认真读，会有收获。</strong></p><img width="40%" src="https://i.loli.net/2019/06/15/5d0448b27802632169.jpg"><p><strong><center>2019 年第 01 本书</center></strong></p><p><strong>推荐读者</strong>：不了解互联网行业，想了解互联网相关工作，想进入到互联网公司工作，想转行到互联网行业的同学。以及在互联网公司工作了一段时间，认为自己有必要了解一下别人如何看到互联网相关工作的，想了解前辈经验的同学。不推荐互联网“老手”读这本书。</p><h2 id="一、互联网公司主要工种和日常工作"><a href="#一、互联网公司主要工种和日常工作" class="headerlink" title="一、互联网公司主要工种和日常工作"></a>一、互联网公司主要工种和日常工作</h2><p>互联网公司员工规模可以大到几万人，也可以小到两三人，规模会根据业务需要而扩大或精简。但是总体来讲主要有<strong>技术岗、销售岗、职能岗、市场岗、运营岗、产品岗和设计岗</strong>这几个部分。互联网公司里，大家都各司其职，<strong>只有经验和能力上的话语权，并不存在太多官大一级压死人的现象。</strong></p><p>本书讲的内容主要是关于互联网公司市场和运营人员的。互联网市场和运营岗位需要你有一定的<strong>文字表达能力</strong>（高考语文及格，语言表达通畅），<strong>熟练使用 Office 和 Photoshop 等办公软件。对数据敏感，沟通表达能力强，具备一定的数据分析能力，以结果为导向等基本能力。</strong></p><p>运营岗可分为活动运营、用户运营、商家运营、品类运营、游戏运营、网店运营和内容运营等。</p><p>作为初入职场的市场和运营的年轻人，脑子比较活，更贴近用户，能够给出很多天马行空的点子，一旦你的想法被采纳，就会得到上级的赏识，职位晋升得也会更快。<strong>在互联网公司，根本无须心存“功高震主”的忌惮。</strong></p><p><strong>给互联网市场和运营人的十个建议：</strong></p><p>1．永远不要说“我不知道”；<br>2．要具备职业精神；<br>3．学会写邮件，例如抄送功能是用来通知你的领导及需要与你跨部门合作的其他部门的领导，你们正在做什么样的工作；<br>4．向上汇报，积极主动向你的直属领导回报你的工作情况；<br>5．不要越俎代庖，做好自己负责的工作，对他人负责的部分提意见可以丢在大群里，他们需要自然会接受；<br>6．疯狂学习，低调处事，用好项目经费，锻炼身体；<br>7．让自己手里的资源流动起来，而不是牢牢捂着不让人碰；<br>8．不要指望面试官一眼看出你靠谱，要主动表达；<br>9．进入职场，你是来工作、成就事业的，不是来交朋友的。顾大局、就事论事，是每一个职场人必备的素养；<br>10．以结果为导向，用数据说话。</p><p>对第七点的补充：你可以通过撮合相互需要认识的人，相互了解并开展合作，以帮助你进一步消化闲置资源，加深你对他们的了解，如业务属性、需求、性格和能力、公司运营状况等，多维度地完善你的资源数据库，同时还可以博得圈内人士的好感，赢得好的口碑，<strong>做一个对他们“有用”的人</strong>，主动权就会到你手上更多了。</p><p>除此之外，作者在本章还讲到了一些互联网的常用英文缩略词和中文专用词等互联网相关的梗。在本章的最后，作者还以一个餐馆的例子来讲述什么是运营、营销、市场和产品。</p><h2 id="二、入门篇：硬技能养成"><a href="#二、入门篇：硬技能养成" class="headerlink" title="二、入门篇：硬技能养成"></a>二、入门篇：硬技能养成</h2><h3 id="文案技巧"><a href="#文案技巧" class="headerlink" title="文案技巧"></a>文案技巧</h3><p>一般写文案主要有三种目的：涨粉、刺激转发和提高转化率。</p><ol><li><strong>以涨粉为目的：</strong>这种类型的文案有几个要素：凸显作者持续提供价值的能力，如商品优惠、干货分享和新鲜资讯等；展现作者和编辑独特的魅力和品位，即使是同类资讯也会有独特的视角；强调作者与订阅者的互动，如不定时发福利和有趣的线下聚会等；身为企业客服的服务态度、人格化标签，让读者有工具性订阅的动机；</li><li><strong>以刺激转发为目的：</strong>赋予文章相应的标签，即可作为转发者炫耀的道具，不论是体现自己知识渊博，爱心泛滥，消息灵通，格调高雅等都可以。内容真实可信，资料准确翔实，出处清晰明了。内容别出心裁，或跌宕起伏，或感人至深；</li><li><strong>以提高转化为目的：</strong>设置高悬念，前文极尽挑逗之能事，在兴致盎然时戛然而止，诱使读者点开链接或扫码。文案内容与所需转发的目的高度相关，饱满且细心地娓娓道来，给予用户充分的转发理由。篇幅不宜过长，一般两屏是极限。字数越多，跳出率越高。力求言简意赅。强调时效性、紧迫性、稀缺性，奖励机制充分，避免用户因迟疑而遗忘；</li><li><strong>以拔高品牌调性为目的：</strong>多用专有名词、外来资料和名人背书等格调性元素打辅助衬托。</li></ol><p>除此之外，作者还讲到一个好标题对一篇文案的重要程度，以及如何快速拟出一个好标题。并且还讲了一篇文章的排版有多重要。</p><h3 id="必备的工作好习惯"><a href="#必备的工作好习惯" class="headerlink" title="必备的工作好习惯"></a>必备的工作好习惯</h3><ol><li>坚持定期向直属领导汇报工作，不要害羞，不要怕挨骂。能直面缺点的人，才能收获最大的成长；</li><li>制定流程，善用工具，包括各种快捷键，磨刀不误砍柴工；</li><li>守时，提前完成基本工作，留足时间检查，做好备选方案，即常说的 Plan B；</li><li>擅用 SMART 原则：</li></ol><ul><li>Specific：绩效指标必须是具体的</li><li>Measurable：绩效指标必须是可以衡量的</li><li>Attainable：绩效指标必须是可以达到的</li><li>Relevant：绩效结果和目标是有相关性的</li><li>Time-bound绩效指标必须具有明确的截止期限</li></ul><ol start="5"><li>全面撒网，重点培养，争取更多的资源并整理归类，维护好自己的资源；</li><li>能花钱的时候绝不刷脸，“脸”应该用在紧急重要的事上；</li><li>保存好你的每一份作品，你不对自己负责，没人会对你负责；</li><li>注意版权，写好出处，可以避免很多不必要的麻烦；</li></ol><h3 id="做好项目结案报告"><a href="#做好项目结案报告" class="headerlink" title="做好项目结案报告"></a>做好项目结案报告</h3><ol><li>结案报告有助于团队之间彼此了解和协调，以便今后更好的分工合作；</li><li>结案报告是对你一个阶段的工作的总结和复盘，帮你及时发现问题，解决问题；</li><li>结案报告也是你的领导向上邀功的重要根据，你结案报告做得好，领导也开心；</li><li>将项目各部门的参与者都感谢一遍，有助于同事间革命友谊的建立；</li><li>结案报告有归纳总结整理项目大部分数据物料的功能；</li><li>结案报告主要需要包括精华数据、项目亮点、品牌效应、详细数据、收获和总结；</li></ol><p>此外，作者在本章还讲到了制作 HTML5 的海报，以及如何提出一个不会被砍掉的需求。</p><h2 id="三、上手篇：软技能提升"><a href="#三、上手篇：软技能提升" class="headerlink" title="三、上手篇：软技能提升"></a>三、上手篇：软技能提升</h2><h3 id="组织一场不会烂尾的脑暴会"><a href="#组织一场不会烂尾的脑暴会" class="headerlink" title="组织一场不会烂尾的脑暴会"></a>组织一场不会烂尾的脑暴会</h3><p>通过头脑风暴，你们可以获得很多好的点子。但是如果组织的不好，则会成为一场浪费生命，浪费感情的烂尾活动。给你一些组织一场不会烂尾的脑暴会的实用性建议：</p><ol><li>尽可能选择舒适的环境</li><li>提前写好提纲，准备好开场素材</li><li>提炼每一个人的发言，复述并传达到位</li><li>做好会议纪要，不让大家白忙一场</li><li>白板上的记录层次分明，逻辑清楚</li></ol><h3 id="商务拓展是什么，做什么，如何做"><a href="#商务拓展是什么，做什么，如何做" class="headerlink" title="商务拓展是什么，做什么，如何做"></a>商务拓展是什么，做什么，如何做</h3><p>BD 即 Business Development Manager，中文为商务拓展经理。</p><p><strong>做 BD，第一件事情，是了解清楚公司的业务流程，产品特性，盈利方式（这是尽可能不要触及的底线），流量如何，注册用户数，客户数，用户画像，潜在价值在哪里，有哪些附加值，老板最愿意拿去交换的资源有哪些，价值多少，销售部门对外报价多少，哪些是绝对不能合作的公司，合作了危害有哪些，等等。下一步，梳理公司已有的资源库。</strong></p><p>寻找品牌调性比较高，用户素质好，市场策划能力较强的公司强强联合，开展有深度的合作，是构筑 BD 核心竞争力的基本课题。</p><p>开始合作时，双方可以先互相聊聊宏观上的各自行业现状和公司地位、各自人群特点，然后聊聊各自的市场实力和操作流程、资源情况，表达一下各自的诚意和对对方公司的极大兴趣。双方合作，更多地是看品牌和影响力以及品牌叠加的化学反应如何。</p><p><strong>办一场小沙龙、讲座、比赛或行业大会，会促使你的能力与日俱增。</strong>把自己变成资源主体，让四面八方主动上门来连接，而不是原来的优盘状态，只能不断从别人的母体蹭一点资源。</p><h3 id="如何与程序员写协作"><a href="#如何与程序员写协作" class="headerlink" title="如何与程序员写协作"></a>如何与程序员写协作</h3><p><strong>与程序员沟通，要指令明确，具有可操作性。</strong>而不要用如差不多、大概、稍微、好看等模糊词；而要明确，如“帮我买一杯 XX 家的珍珠奶茶，热的，七分甜，加椰果和红豆”。解释目的和目标要直观，让他有代入感和大局观。充分尊重，友好真诚，体现出你相信他们比你聪明得多（虽然这是事实）。</p><p><strong>提交 bug 的正确方式：不要说你的代码有 bug。</strong></p><p>你说他代码有 bug，他的第一反应会是：</p><ol><li>你的环境有问题；</li><li>你根本就不会用。</li></ol><p>正确的方式应该是委婉地说：这个程序和预期的有点不一致，你看看是不是我用错了？他本能地会想：是不是出 bug 了！另外注意，这不是一个 bug，而是一种“需求”。</p><h3 id="如何与产品经理协作"><a href="#如何与产品经理协作" class="headerlink" title="如何与产品经理协作"></a>如何与产品经理协作</h3><p>产品经理负责调查并根据用户的需求，确定开发何种产品，选择何种商业模式等，并推动相应产品的开发组织。他还要根据产品的生命周期，协调研发、市场和运营等，确定和组织实施相应的产品策略，以及其他一系列相关的产品管理活动。</p><p>在早期产品新人还没有这个资本树立职场威信的时候，最好跟着前辈亦步亦趋，照葫芦画瓢。在和产品经理沟通合作时，若观念发生冲突，可以做一个内测版的用户体验调查问卷，<strong>用事实和数据告诉他们修改的意见和方向</strong>，并且让他们认识到后期推广的痛点在哪里。</p><h3 id="如何与设计师协作"><a href="#如何与设计师协作" class="headerlink" title="如何与设计师协作"></a>如何与设计师协作</h3><p><strong>给设计师提需求的时候也要注意，你要把图的尺寸，图片上需要的文字，图片风格等信息告诉设计师，并且提前约排期。</strong>而不是你需要图，去找设计师说：“我要做一个 XX 活动，给我做两张图！”</p><p>Dribble、站酷和 Behance，是三大设计师聚集的阵地。站酷偏商业创意设计，Dribble 主要为手机界面图标设计，Behance 则更多的是艺术灵感类设计。</p><h3 id="如何做一份好的策划案"><a href="#如何做一份好的策划案" class="headerlink" title="如何做一份好的策划案"></a>如何做一份好的策划案</h3><p>一份打动人心的策划案，它起码要符合以下几个要素中的任意两条及以上：</p><ol><li>符合当下潮流，是用户民心所向的一项倡议，如天灾人祸时发起的祈福集赞捐款活动；</li><li>能最大限度地发挥产品本身的特性和功效，有助于用户对品牌的认知；</li><li>有稀缺的高价值的机会和资源，如你请得动马云爸爸来站台；</li><li>方案独辟蹊径，网感十足，能充分地调动目标用户的神经，如程序员鼓励师的策划；</li><li>有长尾效应，一次投入长期收益，如人为制造一些节日刺激消费；</li><li>Co-branding 的方案能够达成共赢，有品牌叠加效应，有利于招商拉赞助。</li></ol><h3 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h3><ol><li>百度指数是以百度海量网民行为数据为基础的数据分享平台。百度指数的走势是何种形态，从哪个时间节点开始陡增，倒推哪条媒体渠道效果最好等，都很有借鉴意义。</li><li>新榜：<a href="http://www.newrank.cn" target="_blank" rel="noopener">www.newrank.cn</a></li><li>网站竞争力或相关信息查询：<a href="http://www.cndns.com/whois/toolIndex.aspx" target="_blank" rel="noopener">http://www.cndns.com/whois/toolIndex.aspx</a></li></ol><p>此外，作者在本章还讲到了如何定制一份走心的礼物、如何让老司机心甘情愿地帮你成长。</p><h2 id="四、升华篇：如何做一名合格的市场公关"><a href="#四、升华篇：如何做一名合格的市场公关" class="headerlink" title="四、升华篇：如何做一名合格的市场公关"></a>四、升华篇：如何做一名合格的市场公关</h2><p>市场公关行为主要分为三种：提升知名度、提升美誉度和提升数据。</p><h3 id="如何更好地处理负面事件"><a href="#如何更好地处理负面事件" class="headerlink" title="如何更好地处理负面事件"></a>如何更好地处理负面事件</h3><p>当出现负面事件时，应该坦然地接受指责，感谢大家的指教，态度诚恳地道歉，甚至“过度道歉”，反而会让对方无从下口。一流的高手，都不会自己拼命试图解释，而会用各种手段让别人来替他说出他想要别人说的话。这个技巧，古代皇帝爱用，叫“罪己诏”</p><p><strong>千万不要觉得帮企业圆场是自己的分内之事，这是欺骗，没有一个光荣的工作是以欺骗来立足的。公关更多的角色应该是一个桥梁，架在企业或公众人物和群众之间。</strong></p><p>消除信息的不对称，更清晰地理清事实真相，做传递企业文化的人，甚至应该反过来代替群众去监督企业，向上管理老板，对企业的发展以更顺应民意和社会的角度给出战略发展意见是市场公关的职责。</p><p>提醒一下有志于从事公关行业的朋友们，不要完全信老板说的话，在动笔之前调查清楚事情的全部真相，不要盲目下笔，以致产生不利后果。<strong>做声明时有几个元素一定要注意：</strong></p><ol><li>不要指责媒体；</li><li>消除恶性影响的唯一办法是用正向影响将其覆盖掉；</li><li>打架的时候，弱者才是真正的胜出者；</li><li>反应要及时；</li><li>被谣言攻击的时候，善于运用法律武器。</li></ol><p><strong>在这场浩大的舆论战役中，如果实在做不到谨言慎行，那就关掉手机，不做任何回应，让它慢慢过去，都会好得多。</strong></p><p>公关行为的本质就是将你想要传达的信息经过包装处理，再通过理想的渠道传播给你想传达的人群，并且让他们接受你的信息以及做出你期望的反应（提升好感，或者行为引导）。</p><h3 id="给市场公关的几点建议"><a href="#给市场公关的几点建议" class="headerlink" title="给市场公关的几点建议"></a>给市场公关的几点建议</h3><ol><li>不要平时不烧香，临时抱佛脚。要在圈内积累好人缘、好口碑；</li><li>公司不是你的全部，不要赌上自己的名誉为公司背书，就连 CEO 都没必要和公司同生共死。商业社会，有限责任公司，记住“有限”这两个字，别一腔热血地做炮灰，学会拒绝不合理的要求；</li><li>当遇到自己的意见和老板意见相左的情况时，只要不违背职业道德和法律，一切听老板的。如果确实是一个好的意见，老板却依然固执地坚持己见，你可以考虑换一家公司了。不过，你要保证你的意见确实是好意见。</li></ol><h3 id="舆论操控有这么几个因素缺一不可："><a href="#舆论操控有这么几个因素缺一不可：" class="headerlink" title="舆论操控有这么几个因素缺一不可："></a>舆论操控有这么几个因素缺一不可：</h3><ol><li>耸人听闻的标题；</li><li>逻辑清楚，文笔流畅，加以情绪和煽动力，最好配有图片加以佐证；</li><li>找到传播节点，要么是营销公众号，要么是业内有影响力的名人或者公知；</li><li>话题要有广泛共鸣性，如医闹、著名公共场所的安全事故、知名品牌的恶劣行径。</li></ol><h3 id="君子有所为，有所不为"><a href="#君子有所为，有所不为" class="headerlink" title="君子有所为，有所不为"></a>君子有所为，有所不为</h3><ol><li>工作对事不对人；</li><li>穷寇莫追，见好就收；</li><li>率先对友商发出攻击者输；</li><li>美色如强心针，用多了就失效；</li><li>善用旧物料，可以救急；</li><li>当毫无头绪的时候，可以去做集锦精华清单。</li></ol><h3 id="如何快速做出爆款内容"><a href="#如何快速做出爆款内容" class="headerlink" title="如何快速做出爆款内容"></a>如何快速做出爆款内容</h3><p>想做出爆款内容，首先要记住一点：用户永远不会替你传播，他们只会替自己传播，给他一个标签，让他借你的作品表达自己。</p><ol><li>翻译国外爆款素材，在推特上已经火爆的东西，或者国外新闻第一时间国内发布；</li><li>长草清单（指用来收藏的用户喜欢的购买清单）。不论是推荐书单、化妆品清单、影视剧list，都经久不衰；</li><li>热点事件解读，文笔要犀利，观点要老辣，动作要快；</li><li>鸡汤段落、爆笑表情包的灵活运用，绝对是朽木回春的“速效药”。</li></ol><h3 id="打入网红圈"><a href="#打入网红圈" class="headerlink" title="打入网红圈"></a>打入网红圈</h3><p>网红大概分为几类：第一类，社会名人自带网红属性；第二类，草根号一心做大想接广告的；第三类，自娱自乐一不小心红了的无欲无求族。</p><p>第一种类型的人最难接近。因为社会地位悬殊，与他们基本没有平等对话的机会；</p><p>第二种类型的人，不要期盼对方有空陪你闲聊；</p><p>第三种类型的人，通常是最有趣也是最有交往价值的人，他们什么都不缺，没有太多功利心。当然他们也因此对私人联系会有洁癖，他们对智商和格调异常敏感，只会交往自己喜欢的同类，把自己变成他们的同类，或者充分展示你的有趣，是唯一能敲开他们私人世界大门的敲门砖。</p><p>对于网红来说，对来访者是否是自己的 follower 会格外敏感。如果连订阅或者扩散自己作品的举动都没有，却来索取或者求交往的，多半要吃闭门羹，可以先转发一条最新微博或者知乎上点个赞再去发私信，大多数人都会随手点开看一眼，这样的行为多少可以加点分，知道你不是个“伸手党”。</p><h2 id="五、全能的市场人"><a href="#五、全能的市场人" class="headerlink" title="五、全能的市场人"></a>五、全能的市场人</h2><p>在本章，作者给出了当对手上门挑衅时，你要记住的三个重要原则：</p><ul><li>重要原则 1：不要和名气不如你的对手吵架；</li><li>重要原则 2：只有你关注自己受的委屈；</li><li>重要原则 3：打人不打脸，骂人不揭短，点到为止。</li></ul><p>此外，作者在本章还写到，在活动执行时，如何挑选靠谱的供应商，市面上的部分媒介的优缺点以及如何办一场线下活动。并且还通俗地讲了期权和加薪等基本的财务问题。</p><p>作者结合个人经历，讲到市场人有哪些职业病；在思路枯竭时，如何打开思路；有野心的员工才能进步地更快。作者认为写作是这个时代白手起家的最短路径，当然还有很多其他的赚钱方式。</p><p>在大城市，靠着每个月的工资买房？基本是不现实的。真正拉开差距的是正常工作以外的时间。大城市，机会很多，关键在于你是否能发现，发现了是否有能力承接，承接了是否能坚持做好。</p><p><strong>不要吐槽北上广房价贵，很少有人真的能靠工资买房。拉开差距的，还是八小时以外啊。或充电，或赚钱，唯独时光与青春不可辜负。</strong></p><h2 id="六、教你玩儿转自媒体"><a href="#六、教你玩儿转自媒体" class="headerlink" title="六、教你玩儿转自媒体"></a>六、教你玩儿转自媒体</h2><p>在这一章，作者对豆瓣、知乎、微博、微信、直播平台、自制短视频等的过去和今天进行了分析。作者认为短视频是下一个战场，并结合自己的经历，讲了如何获取视频流量等。</p><p>短视频为什么会火，因为有大量学历不高的网民支撑，这部分网民的共同点是比较闲，工作压力不大，喜欢低俗无厘头且不用思考的视频短片，看完哈哈一笑之后便继续漫无目的地点击下一个视频或刷刷朋友圈，他们现在对视频短片质量要求不高。</p><p>作者还讲到，做市场营销时，如果实在是资源枯竭，也可以将老板“卖”出去，通过情怀牌、“逗比”牌和悲情牌等方式，对老板进行包装，打造老板的好形象。</p><p>有一点我印象很深刻，就是微博的口碑营销应该怎么做：</p><ol><li>从项目提出到立案，我们需要拆分项目的核心引爆点，主打八卦还是反转还是异业合作的化学反应或者是搞笑段子；</li><li>然后定好预算和目的。如花费3万元达到200万的阅读和曝光或者100个以上的转发，还是有几十个几百个转化，从链接或者其他入口跳转引流；</li><li>创意和策划。需要别树一帜的文案和素材，能够瞬间引爆眼球；</li><li>落地撰稿、修改文案、定稿、发布和购买大号转发或者直发；</li><li>跟踪数据反馈，查看自然传播流量和口碑，做好引爆点分析；</li><li>结案和复盘。</li></ol><h2 id="七、作者的工作心得"><a href="#七、作者的工作心得" class="headerlink" title="七、作者的工作心得"></a>七、作者的工作心得</h2><p>作者结合自己的经历，对如何选择一份不会后悔的 offer 给出了以下的建议：</p><ol><li>行业是有前景的，公司是有“钱”景的；</li><li>老板是有人格魅力的，能让人心服口服，并且带领公司和部门走向成功；</li><li>待遇福利处于行业领先地位；</li><li>公司在招聘时就能严格筛选，招收的员工就是价值观匹配、兴趣点相同，能力和需求高度吻合。并且能给予员工极大的成就感、存在感、满足感；</li><li>公司有专业的 HR 定期考核，并跟踪、关心员工的心理状况变化；</li><li>公司不在员工离职的时候才加薪、给福利，每年有定期的薪资涨幅。</li></ol><p>作者结合自己做的一个精品高端社群项目讲到，一个优质的社群可以成为人脉结点，是连接高质量用户的桥梁，并且刺激高质量用户的输出和传播，使其甚至有可能会成为网站本身的产品使用者，从而提高整个网站的口碑、用户含金量和生态多样性，从而建立行业壁垒。</p><p>社群有按照职能区分的，如程序员群、产品群、运营群；也有按照目的区分的，如读书群、跑步群、分享干货群。可以有少量交叉，既能满足同业交流，又能满足跨界沟通。</p><p><strong>虽然赚钱重要，但是涉及到金钱和生命、健康的东西，做市场、做媒体的，如果没有足够的专业知识，凭借自己的创意文案让人做出选择，背后的责任你承担不起。</strong></p><p>在最后，作者分享了一些自己做用户运营、新媒体运营和渠道运营的一些坑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天分享的书是《全栈市场人》，作者是 Lydia。本书出版于 2017 年 02 月，全书共有七章，包括互联网基础知识、互联网市场人、运营人所需要的软硬技能、网感的养成、市场人的工作内容介绍、教你玩转自媒体，以及作者的个人工作经验分享。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.dingxuewen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="营销" scheme="https://www.dingxuewen.com/tags/%E8%90%A5%E9%94%80/"/>
    
      <category term="微信读书" scheme="https://www.dingxuewen.com/tags/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="运营" scheme="https://www.dingxuewen.com/tags/%E8%BF%90%E8%90%A5/"/>
    
      <category term="市场" scheme="https://www.dingxuewen.com/tags/%E5%B8%82%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>2018 年「掘金翻译计划」年度总结：我们共同的成长故事</title>
    <link href="https://www.dingxuewen.com/article/annual-summary-of-the-juejin-translation-plan-for-2018/"/>
    <id>https://www.dingxuewen.com/article/annual-summary-of-the-juejin-translation-plan-for-2018/</id>
    <published>2019-01-13T08:56:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>在掘金翻译计划的 2018 年里，共有 300 余名译者参与到国外优质英文文章的翻译和校对工作当中，共输出了 570 余篇优质译文。与广大开发者们一起学习和分享最新的技术内容。</p><a id="more"></a><p>从 2015 年 11 月开始，我们发起了掘金翻译计划，现已成长为可能是世界最大最好的英译中技术社区和翻译平台。我们已有超过 <a href="https://github.com/xitu/gold-miner#%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92" target="_blank" rel="noopener">1000 位</a> 优秀的译者，今年翻译了 <a href="https://github.com/xitu/tensorflow-docs" target="_blank" rel="noopener">TensorFlow 官方中文文档</a>，<a href="https://zh.javascript.info/" target="_blank" rel="noopener">现代 JavaScript 教程</a>，<a href="https://legacy.gitbook.com/book/leviding/front-end-handbook-2018/details" target="_blank" rel="noopener">2018 年前端开发者指南</a> 和 <a href="https://mlkit.cn" target="_blank" rel="noopener">mlkit.cn</a>，并与 Google 团队合作，完成了 <a href="https://juejin.im/post/5a6e7f726fb9a01c99510f5c" target="_blank" rel="noopener">Android 官方文档的翻译优化</a>。</p><p>翻译计划目前已经翻译完成 <a href="https://github.com/xitu/gold-miner#近期文章列表" target="_blank" rel="noopener">1370</a> 余篇文章，官方文档及手册 <a href="https://github.com/xitu/gold-miner#官方文档及手册" target="_blank" rel="noopener">13</a> 个，共有 <a href="https://github.com/xitu/gold-miner/wiki/%E8%AF%91%E8%80%85%E7%A7%AF%E5%88%86%E8%A1%A8" target="_blank" rel="noopener">1000</a> 余名译者贡献翻译和校对。GitHub Star 18450+，Watch 1080+，Fork 3140+。</p><p>这不仅是掘金翻译计划的 2018，更是我们一起成长的故事～</p><h2 id="翻译计划发展历程"><a href="#翻译计划发展历程" class="headerlink" title="翻译计划发展历程"></a>翻译计划发展历程</h2><ol><li>2015 年 11 月，掘金翻译计划成立，并产生了第一个 commit；</li><li>2016 年 04 月，翻译计划 Repo 突破 1000 Star；</li><li>2017 年 06 月，正式完整翻译了第一个大型文档<a href="https://github.com/xitu/front-end-handbook-2017" target="_blank" rel="noopener">《2017 年前端开发者指南》</a>；</li><li>2017 年 09 月，译者团队突破 500 人；</li><li>2017 年 11 月，<a href="https://github.com/xitu/gold-miner/issues/2504" target="_blank" rel="noopener">翻译计划 Repo 突破 10000 Star</a>；</li><li>2018 年 01 月，与 Google 团队合作，<a href="https://juejin.im/post/5a6e7f726fb9a01c99510f5c" target="_blank" rel="noopener">完成了 Android 官方文档的翻译优化</a>；</li><li>2018 年 02 月，受原作者邀请，翻译完成了<a href="https://github.com/xitu/front-end-handbook-2018" target="_blank" rel="noopener">《2018 年前端开发者指南》</a>；</li><li>2018 年 03 月，<a href="https://juejin.im/post/5aafa4036fb9a028e33b410a" target="_blank" rel="noopener">发布了 TensorFlow 官方文档中文版</a>，并且持续更新维护；</li><li>2018 年 05 月，上线了 <a href="https://mlkit.cn" target="_blank" rel="noopener">Google ML Kit 中文文档 https://mlkit.cn</a>；</li><li>2018 年 11 月，上线了大型翻译项目：<a href="https://zh.javascript.info/" target="_blank" rel="noopener">现代 JavaScript 权威指南（The Morden Javascript Tutorial）</a>；</li><li>2019 年 01 月，译者团队人数突破 1000！</li><li>未来，你与我一同创造～</li></ol><h2 id="翻译计划目前的基本情况"><a href="#翻译计划目前的基本情况" class="headerlink" title="翻译计划目前的基本情况"></a>翻译计划目前的基本情况</h2><p>现在，掘金翻译计划内容覆盖<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#ai--deep-learning--machine-learning" target="_blank" rel="noopener">人工智能</a>、<a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>和<a href="https://github.com/xitu/gold-miner#其他" target="_blank" rel="noopener">其他</a> 等领域，以及各大型优质 <a href="https://github.com/xitu/gold-miner#官方文档及手册" target="_blank" rel="noopener">官方文档及手册</a>，读者为热爱新技术的新锐开发者。</p><p>目前已经翻译完成 <a href="https://github.com/xitu/gold-miner#近期文章列表" target="_blank" rel="noopener">1370</a> 余篇文章，官方文档及手册 <a href="https://github.com/xitu/gold-miner#官方文档及手册" target="_blank" rel="noopener">13</a> 个，共有 <a href="https://github.com/xitu/gold-miner/wiki/%E8%AF%91%E8%80%85%E7%A7%AF%E5%88%86%E8%A1%A8" target="_blank" rel="noopener">1000</a> 余名译者贡献翻译和校对。</p><h2 id="翻译计划是怎么样工作的"><a href="#翻译计划是怎么样工作的" class="headerlink" title="翻译计划是怎么样工作的"></a>翻译计划是怎么样工作的</h2><p>掘金翻译计划是一个翻译优质互联网技术文章的社区，译者主要来自于自荐。想成为翻译计划译者的同学，可以<a href="https://github.com/xitu/gold-miner/wiki/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E7%BF%BB%E8%AF%91" target="_blank" rel="noopener">在 GitHub 上发 Issue 进行申请</a>。译者自荐后，需要进行翻译计划译者教程的学习，之后由管理员来审核加入。加入翻译计划后先校对至少一篇文章，熟悉流程，之后可以开始认领文章的翻译。</p><p>文章主要来源于国外优秀网站，主要有管理员筛选和译者及其他志愿者推荐。发布在翻译计划任务列表中的文章，需要经过一位译者翻译，两位译者校对，最后经过管理员审校，才能够合并到翻译计划中。</p><p>当译者及分子攒到一定数量后，可以兑换相关奖品，想要兑换奖品的译者，直接微信私聊管理员即可，管理员收到信息后，会在一周内将礼物寄出。掘金翻译计划礼物列表详见：<a href="https://github.com/xitu/gold-miner/wiki#%E5%B0%8F%E7%A4%BC%E5%93%81%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/wiki#%E5%B0%8F%E7%A4%BC%E5%93%81%E5%88%97%E8%A1%A8</a></p><h2 id="年度译者前-30-名"><a href="#年度译者前-30-名" class="headerlink" title="年度译者前 30 名"></a>年度译者前 30 名</h2><table><thead><tr><th>排名</th><th>译者</th><th>年度积分</th><th>排名</th><th>译者</th><th>年度积分</th><th>排名</th><th>译者</th><th>年度积分</th></tr></thead><tbody><tr><td>1</td><td><a href="https://juejin.im/user/595d85cef265da6c2d2c6bb7" target="_blank" rel="noopener">Starriers</a></td><td>433 积分</td><td>11</td><td><a href="https://juejin.im/user/5b18bddc6fb9a01e7342d5e7" target="_blank" rel="noopener">geniusq1981</a></td><td>77.5 积分</td><td>21</td><td><a href="https://juejin.im/user/5867b7b3b123db005de29198" target="_blank" rel="noopener">hanliuxin5</a></td><td>57.5 积分</td></tr><tr><td>2</td><td><a href="https://juejin.im/user/5a77c24cf265da4e747f92e8" target="_blank" rel="noopener">zhmhhu</a></td><td>105.5 积分</td><td>12</td><td><a href="https://juejin.im/user/57b07b140a2b580063262e50" target="_blank" rel="noopener">sunhaokk</a></td><td>73.5 积分</td><td>22</td><td><a href="https://github.com/zhusimaji" target="_blank" rel="noopener">zhusimaji</a></td><td>57.5 积分</td></tr><tr><td>3</td><td><a href="https://juejin.im/user/5aa78c1651882555712c06f8" target="_blank" rel="noopener">ALVINYEH</a></td><td>99 积分</td><td>13</td><td><a href="https://juejin.im/user/5a141f97f265da43346f8b6b" target="_blank" rel="noopener">sisibeloved</a></td><td>68 积分</td><td>23</td><td><a href="https://juejin.im/user/5ad6e200518825556e5e9d68" target="_blank" rel="noopener">luochen1992</a></td><td>57 积分</td></tr><tr><td>4</td><td><a href="https://juejin.im/user/5b421b05e51d45190905d875" target="_blank" rel="noopener">pkuwwt</a></td><td>93.5 积分</td><td>14</td><td><a href="https://juejin.im/user/57b2cc33165abd0054378122" target="_blank" rel="noopener">Raoul1996</a></td><td>67 积分</td><td>24</td><td><a href="https://juejin.im/user/57a9a6ea5bbb50006441d5ee" target="_blank" rel="noopener">steinliber</a></td><td>57 积分</td></tr><tr><td>5</td><td><a href="https://juejin.im/user/582027b72e958a0054f4ecbe" target="_blank" rel="noopener">CoolRice</a></td><td>92 积分</td><td>15</td><td><a href="https://juejin.im/user/594b85818d6d810057def05c" target="_blank" rel="noopener">Moonliujk</a></td><td>65 积分</td><td>25</td><td><a href="https://juejin.im/user/582419f30ce4630058b08dc0" target="_blank" rel="noopener">athena0304</a></td><td>55.5 积分</td></tr><tr><td>6</td><td><a href="https://juejin.im/user/58d61ff1570c350058d2df0f" target="_blank" rel="noopener">lsvih</a></td><td>87.5 积分</td><td>16</td><td><a href="https://juejin.im/user/596f1d3551882541941ff5bc" target="_blank" rel="noopener">jonjia</a></td><td>64 积分</td><td>26</td><td><a href="https://juejin.im/user/57b012658ac247005f0a49ce" target="_blank" rel="noopener">changkun</a></td><td>55 积分</td></tr><tr><td>7</td><td><a href="https://juejin.im/user/5a08ec226fb9a04508092317" target="_blank" rel="noopener">JohnJiangLA</a></td><td>85.5 积分</td><td>17</td><td><a href="https://juejin.im/user/5aa034ac6fb9a028c22a5482" target="_blank" rel="noopener">7Ethan</a></td><td>62.5 积分</td><td>27</td><td><a href="https://juejin.im/user/5643082560b294bc6089b8d7" target="_blank" rel="noopener">sqrthree</a></td><td>55 积分</td></tr><tr><td>8</td><td><a href="https://juejin.im/user/5a4b4f915188252bca053c71" target="_blank" rel="noopener">EmilyQiRabbit</a></td><td>82 积分</td><td>18</td><td><a href="https://juejin.im/user/5abc3ba16fb9a028d37577a8" target="_blank" rel="noopener">haiyang-tju</a></td><td>61.5 积分</td><td>28</td><td><a href="https://juejin.im/user/5858cd5e61ff4b006874e4fc" target="_blank" rel="noopener">ssshooter</a></td><td>54 积分</td></tr><tr><td>9</td><td><a href="https://juejin.im/user/585b9407da2f6000657a5c0c" target="_blank" rel="noopener">rydensun</a></td><td>80 积分</td><td>19</td><td><a href="https://juejin.im/user/58e48dc38d6d810061654870" target="_blank" rel="noopener">lihanxiang</a></td><td>59 积分</td><td>29</td><td><a href="https://juejin.im/user/59120a711b69e6006865dd7b" target="_blank" rel="noopener">MeFelixWang</a></td><td>52 积分</td></tr><tr><td>10</td><td><a href="https://juejin.im/user/5757aa66a341310061239f33" target="_blank" rel="noopener">Colafornia</a></td><td>79.5 积分</td><td>20</td><td><a href="https://juejin.im/user/58870e0f128fe100684488b1" target="_blank" rel="noopener">pot-code</a></td><td>58.5 积分</td><td>30</td><td><a href="https://juejin.im/user/587c1aaab123db005df3b472" target="_blank" rel="noopener">cf020031308</a></td><td>50 积分</td></tr></tbody></table><p><strong>所有译者信息，详见 👉 <a href="https://github.com/xitu/gold-miner/blob/master/integrals.md" target="_blank" rel="noopener">译者积分表</a></strong>，感谢你们的辛勤付出 👍</p><h2 id="年度文章-22-篇"><a href="#年度文章-22-篇" class="headerlink" title="年度文章 22 篇"></a>年度文章 22 篇</h2><ol><li>TensorFlow 官方文档中文版发布啦（持续维护）：<a href="https://juejin.im/post/5aafa4036fb9a028e33b410a" target="_blank" rel="noopener">https://juejin.im/post/5aafa4036fb9a028e33b410a</a></li><li>[译] 理解 JavaScript 中的执行上下文和执行栈：<a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">https://juejin.im/post/5ba32171f265da0ab719a6d7</a></li><li>[译] 以面试官的角度来看 React 工作面试：<a href="https://juejin.im/post/5bca74cfe51d450e9163351b" target="_blank" rel="noopener">https://juejin.im/post/5bca74cfe51d450e9163351b</a></li><li>[译] 五个小技巧让你写出更好的 JavaScript 条件语句：<a href="https://juejin.im/post/5bb9e3085188255c352d7326" target="_blank" rel="noopener">https://juejin.im/post/5bb9e3085188255c352d7326</a></li><li>[译] 2018 要学习的优秀 JavaScript 库与知识：<a href="https://juejin.im/post/5a4e23f0f265da3e377bce4f" target="_blank" rel="noopener">https://juejin.im/post/5a4e23f0f265da3e377bce4f</a></li><li>[译] 2017 前端技术发展回顾：<a href="https://juejin.im/post/5aa094ca518825555c1d31a6" target="_blank" rel="noopener">https://juejin.im/post/5aa094ca518825555c1d31a6</a></li><li>[译] 为什么 Flutter 能最好地改变移动开发：<a href="https://juejin.im/post/5add65c46fb9a07aa541e97e" target="_blank" rel="noopener">https://juejin.im/post/5add65c46fb9a07aa541e97e</a></li><li>[译] 你不知道的 console 命令：<a href="https://juejin.im/post/5bf64218e51d45194266acb7" target="_blank" rel="noopener">https://juejin.im/post/5bf64218e51d45194266acb7</a></li><li>[译] 布局的下一次革新：<a href="https://juejin.im/post/5b85586ce51d4538c77a9cc1" target="_blank" rel="noopener">https://juejin.im/post/5b85586ce51d4538c77a9cc1</a></li><li>[译] 2018 前端性能优化清单 - 第 4 部分：<a href="https://juejin.im/post/5a62aa686fb9a01c91407a0b" target="_blank" rel="noopener">https://juejin.im/post/5a62aa686fb9a01c91407a0b</a></li><li>[译] 如何停止使用 console.log() 并开始使用浏览器调试代码：<a href="https://juejin.im/post/5bd7cde4f265da0a96251de3" target="_blank" rel="noopener">https://juejin.im/post/5bd7cde4f265da0a96251de3</a></li><li>[译] 什么是模块化 CSS？：<a href="https://juejin.im/post/5bb6c5195188255c9e02e6f3" target="_blank" rel="noopener">https://juejin.im/post/5bb6c5195188255c9e02e6f3</a></li><li>[译] 一行 JavaScript 代码竟然让 FT.com 网站慢了十倍：<a href="https://juejin.im/post/5b7bb6dfe51d4538bf55aa5f" target="_blank" rel="noopener">https://juejin.im/post/5b7bb6dfe51d4538bf55aa5f</a></li><li>[译] 我未曾见过的 JS 特性：<a href="https://juejin.im/post/5a723216f265da3e2e62d0a5" target="_blank" rel="noopener">https://juejin.im/post/5a723216f265da3e2e62d0a5</a></li><li>[译] Flutter — 五个你会爱上它的原因：<a href="https://juejin.im/post/5a9e7e89f265da2381552542" target="_blank" rel="noopener">https://juejin.im/post/5a9e7e89f265da2381552542</a></li><li>[译] 带你领略 ConstraintLayout 1.1 的新功能：<a href="https://juejin.im/post/5b013e6f51882542c760dc7b" target="_blank" rel="noopener">https://juejin.im/post/5b013e6f51882542c760dc7b</a></li><li>[译] this（他喵的）到底是什么 — 理解 JavaScript 中的 this、call、apply 和 bind：<a href="https://juejin.im/post/5b9f176b6fb9a05d3827d03f" target="_blank" rel="noopener">https://juejin.im/post/5b9f176b6fb9a05d3827d03f</a></li><li>[译] webpack 4 测试版 — 现在让我们先一睹为快吧：<a href="https://juejin.im/post/5a72d569f265da3e3a6e2118" target="_blank" rel="noopener">https://juejin.im/post/5a72d569f265da3e3a6e2118</a></li><li>[译] webpack 4 测试版 — 现在让我们先一睹为快吧：<a href="https://juejin.im/post/5a72d569f265da3e3a6e2118" target="_blank" rel="noopener">https://juejin.im/post/5a72d569f265da3e3a6e2118</a></li><li>[译] 提高 10 倍性能：优化静态网站：<a href="https://juejin.im/post/5ac9e430f265da2392369ec0" target="_blank" rel="noopener">https://juejin.im/post/5ac9e430f265da2392369ec0</a></li><li>[译] 可用但最不常见的 HTML5 标签：<a href="https://juejin.im/post/5b0026e8f265da0b8c253c2a" target="_blank" rel="noopener">https://juejin.im/post/5b0026e8f265da0b8c253c2a</a></li><li>[译] 这些 CSS 命名规范将省下你大把调试时间：<a href="https://juejin.im/post/5a6c5881518825733201daf7" target="_blank" rel="noopener">https://juejin.im/post/5a6c5881518825733201daf7</a></li></ol><h2 id="翻译计划大型文档和-Glossary"><a href="#翻译计划大型文档和-Glossary" class="headerlink" title="翻译计划大型文档和 Glossary"></a>翻译计划大型文档和 Glossary</h2><ul><li><a href="https://zh.javascript.info/" target="_blank" rel="noopener">现代 JavaScript 权威指南（The Morden Javascript Tutorial）</a></li><li><a href="https://github.com/xitu/tensorflow" target="_blank" rel="noopener">TensorFlow 官方文档翻译（长期维护）</a></li><li><a href="https://github.com/Quorafind/MLkit-CN" target="_blank" rel="noopener">ML Kit 中文文档</a></li><li><a href="https://github.com/xitu/graphql.github.io" target="_blank" rel="noopener">GraphQL 中文文档（长期维护）</a></li><li><a href="https://github.com/xitu/Under-the-hood-ReactJS" target="_blank" rel="noopener">Under-the-hood-ReactJS 系列教程</a></li><li><a href="https://github.com/xitu/system-design-primer" target="_blank" rel="noopener">系统设计入门教程</a></li><li><a href="https://github.com/xitu/google-interview-university" target="_blank" rel="noopener">Google Interview University 面试指北</a></li><li><a href="https://github.com/xitu/front-end-handbook-2018" target="_blank" rel="noopener">前端开发者指南（2018）</a></li><li><a href="https://github.com/xitu/front-end-handbook-2017" target="_blank" rel="noopener">前端开发者指南（2017）</a></li><li><a href="https://github.com/xitu/awesome-flutter" target="_blank" rel="noopener">Awesome Flutter</a></li><li><a href="https://github.com/xitu/macOS-Security-and-Privacy-Guide" target="_blank" rel="noopener">macOS Security and Privacy Guide</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/state-of-vue-report-2017.md" target="_blank" rel="noopener">State of Vue.js report 2017 中文版</a></li><li><a href="http://nextjs.frontendx.cn/" target="_blank" rel="noopener">Next.js 轻量级 React 服务端渲染应用框架中文文档</a></li><li><a href="https://github.com/xitu/gold-miner/wiki/Glossary-of-Android" target="_blank" rel="noopener">Glossary of Android</a></li><li><a href="https://github.com/xitu/gold-miner/wiki/Glossary-of-Blockchain" target="_blank" rel="noopener">Glossary of Blockchain</a></li></ul><h2 id="译文分类列表汇总"><a href="#译文分类列表汇总" class="headerlink" title="译文分类列表汇总"></a>译文分类列表汇总</h2><ul><li><a href="https://github.com/xitu/gold-miner/blob/master/blockchain.md" target="_blank" rel="noopener">所有区块链译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/AI.md" target="_blank" rel="noopener">所有 AI 译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/android.md" target="_blank" rel="noopener">所有 Android 译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/ios.md" target="_blank" rel="noopener">所有 iOS 译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/front-end.md" target="_blank" rel="noopener">所有前端译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/backend.md" target="_blank" rel="noopener">所有后端译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/design.md" target="_blank" rel="noopener">所有设计译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/product.md" target="_blank" rel="noopener">所有产品译文&gt;&gt;</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/others.md" target="_blank" rel="noopener">所有其他分类译文&gt;&gt;</a></li></ul><h2 id="教程类译文："><a href="#教程类译文：" class="headerlink" title="教程类译文："></a>教程类译文：</h2><ul><li><a href="https://juejin.im/post/59950fd9f265da248535b46d?utm_source=gold-miner&utm_medium=readme&utm_campaign=github" target="_blank" rel="noopener">为什么我还没 Fix 你的 Issue</a> (<a href="https://github.com/leviding" target="_blank" rel="noopener">leviding</a> 翻译)</li><li><a href="http://gold.xitu.io/entry/56d56f4dc4c971005193ecec?utm_source=gold-miner&utm_medium=readme&utm_campaign=github" target="_blank" rel="noopener">Chrome 开发者工具提示和技巧</a> (<a href="https://github.com/chemzqm" target="_blank" rel="noopener">chemzqm</a> 翻译)</li><li><a href="http://gold.xitu.io/entry/56aae5e4a633bd0257ae4ab8?utm_source=gold-miner&utm_medium=readme&utm_campaign=github" target="_blank" rel="noopener">通过 Electron 开发一个简单的桌面应用</a> (<a href="https://github.com/Zhangdroid" target="_blank" rel="noopener">Zhangdroid</a> 翻译)</li><li><a href="http://gold.xitu.io/entry/56cc4085128fe100580dd0ca?utm_source=gold-miner&utm_medium=readme&utm_campaign=github" target="_blank" rel="noopener">Retrofit 入门教程</a> (<a href="https://github.com/xiuweikang" target="_blank" rel="noopener">kevin xiu</a> 翻译)</li><li><a href="http://gold.xitu.io/entry/56cebb8edf0eea79dc7c1ff0?utm_source=gold-miner&utm_medium=readme&utm_campaign=github" target="_blank" rel="noopener">Pokedex.org 给宠物小精灵爱好者的 web app 的技术选型</a> (<a href="https://github.com/RobertWang" target="_blank" rel="noopener">RobertWang</a> 翻译)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2018 我们一直致力于新技术的生产和传播，2019 我们会继续提供更优质的内容给每一个清晨挤在的地铁 🚇、公交 🚌上的你，给午后埋头工作的你，给凌晨到午夜秉烛夜读的你。</p><h2 id="致谢译者"><a href="#致谢译者" class="headerlink" title="致谢译者"></a>致谢译者</h2><p>在大家的共同努力下，掘金翻译计划又长了一岁，2018 年是掘金翻译计划飞速发展的一年，这一年无论是在译者团队的规模上，在输出译文的数量上，还是在翻译计划的影响力上，都有了极大的提升。</p><p>感谢各位译者这一年来对掘金翻译计划的支持，有了你们的支持，掘金翻译计划才能不断壮大，提高咱们的影响力，为更多开发者、更多的企业服务，营造更好的技术氛围。</p><p>2019，希望我们都能看到更好的自己 😊</p><h2 id="欢迎译者和合作商参与翻译计划"><a href="#欢迎译者和合作商参与翻译计划" class="headerlink" title="欢迎译者和合作商参与翻译计划"></a>欢迎译者和合作商参与翻译计划</h2><p>对掘金翻译计划感兴趣的，同时对自身要求较高（有强迫症）、英文不错同时又会点技术（方向不限）的小伙伴，你们在哪，请用你的小手拿起鼠标 <a href="https://github.com/xitu/gold-miner/" target="_blank" rel="noopener">点击这里加入我们</a>。</p><p>想与掘金翻译计划进行合作的公司或者其他合作商，可以加微信 517010193 详谈（备注翻译计划合作）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在掘金翻译计划的 2018 年里，共有 300 余名译者参与到国外优质英文文章的翻译和校对工作当中，共输出了 570 余篇优质译文。与广大开发者们一起学习和分享最新的技术内容。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="https://www.dingxuewen.com/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="成长" scheme="https://www.dingxuewen.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="工作" scheme="https://www.dingxuewen.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="思考" scheme="https://www.dingxuewen.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>道理我都懂，只是懒？—《认知突围》</title>
    <link href="https://www.dingxuewen.com/article/i-understand-the-truth-just-lazy/"/>
    <id>https://www.dingxuewen.com/article/i-understand-the-truth-just-lazy/</id>
    <published>2018-08-27T08:56:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>你可能常听到这句话“道理我都懂，只是懒。”这是让人听了会十分感慨的一句话，懂了那么多道理，依然过不好这一生。其实你不懂，所以认为自己只是懒。你停下来思考一下，问自己几个问题，判断某个道理自己是不是真懂、愿不愿意懂、值不值得懂的标志是什么？</p><a id="more"></a><p>人们会给出五花八门的答案,在我看来,答案只有一个就是你有没有按照“道理”所述去践行。如果你真的认为它有道理,那你为什么不去践行呢?不去践行的原因可能有一下几个：</p><ul><li>你并没有真懂</li><li>你并不认为它一定能指向某个你想要的结果</li><li>它带来的结果并不足够吸引你</li></ul><p>对一个正确的道理表现出懒惰,就是认知能力不足的体现。认为自己懒,说明自己认为自己能变得更好却不愿意变得更好。这里有两种情况：</p><ul><li>一种是对自己能力的高估</li><li>另一种是对自卑的保护</li></ul><p>明确认识到自己懒却不愿意变得“不那么懒”,证明他们对于如何正确做事的认知模糊不清,并不清楚付出更多的成本能否带来更好的结果。所以选择懒的这个行为,本质上是看不到正确做事能带来的巨大好处。</p><p>有人说不肯用功是自制力不足。这的确是一方面，但自知力不足的本质不也是认知不足吗？</p><p>例如学习：</p><ul><li>很多人认不清学习有什么用</li><li>或者看不到学习和自己未来想要的结果之间的强关联性</li><li>或者根本不认为它们之间有强关联性</li></ul><p>因此才会选择不用功。</p><p>举个简单的例子，如果有人要跟你签一个合约，让你每周坚持消化两本书,每天早晨 5 点起来跑步一小时并从早上 7 点拼命工作到晚上 9 点,再进行一小时的深度思考然后才能休息,只要你坚持 10 年,就把这一个亿给你。我相信很多人在这种回报的诱惑下,是可以坚持下来的。因为什么？因为做这些事儿跟一个亿确实有着强关联性。但现在不和你签合约，而是告诉你这样的道理，说这么赶就肯定能赚大钱，相信 90% 的人就坚持不下来了。因为大多数人的认知看不到这么远。</p><p>当回报在某些人眼里不存在或不明显时,他们的动力就不足了自然表现出懒的特性。但是在另一些人眼里,未来的回报却是清晰可见的,于是他们选择努力。现在你还能说,自己天生就是懒吗?</p><p>懒并不是什么遮羞布,这恰恰是你跟别人在认知上的差距。</p><p>再举个例子，你办了一张健身卡，给自己设定了健身目标。但是你今天下班了有点累，就给自己找借口，说昨天练的太多了，今天浑身疼就不去了。但是如果明天上午你有一个商务会谈，你肯定会认真准备认真对待。这是因为在做选择和决策的时候，人们会考虑根据事情的性质、风险以及付出与收获来排出自己心里的优先级。</p><p>优先级是人主观设定的，有的人 60 分的事儿也会拼尽全力，有些人 90 分的事儿才会挪一挪屁股。</p><p>那怎样能够把事儿做得更好呢？</p><ol><li>首先认清自己。</li><li>学会分解任务。</li><li>衍生任务未完成的间接后果。</li><li>养成说断就断的习惯。</li><li>给自己阶段性的奖赏，循序渐进。</li></ol><hr><p>本文为《认知突围：做复杂时代的明白人》一书的读后感，本书作者为蔡垒磊。全书共分为七章，分别为重新认识自己、重新认识知识、重新认识金钱、重新认识时间、重新认识关系、重新认识人生和后记。书中有少部分内容还不错，只不过全书鸡汤感较足，可读可不读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能常听到这句话“道理我都懂，只是懒。”这是让人听了会十分感慨的一句话，懂了那么多道理，依然过不好这一生。其实你不懂，所以认为自己只是懒。你停下来思考一下，问自己几个问题，判断某个道理自己是不是真懂、愿不愿意懂、值不值得懂的标志是什么？&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.dingxuewen.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://www.dingxuewen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>译文：为什么我们从来不去感谢开源项目维护者</title>
    <link href="https://www.dingxuewen.com/article/why-we-never-thank-open-source-maintainers/"/>
    <id>https://www.dingxuewen.com/article/why-we-never-thank-open-source-maintainers/</id>
    <published>2017-12-25T10:20:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>你现在可以到 <a href="https://www.thankyouopensource.com" target="_blank" rel="noopener">Thank you, open source</a> 这个网站上为你最喜欢的开源项目写一句感谢的话了。</p><p>下面是我对为什么我们从来不去感谢开源项目维护者的一些看法。</p><a id="more"></a><h2 id="这样的项目我也可以做啊"><a href="#这样的项目我也可以做啊" class="headerlink" title="这样的项目我也可以做啊"></a>这样的项目我也可以做啊</h2><blockquote><p>“蛤？这项目对我来说也太简单了吧。”</p><p>“我一周之内就能做一个更好的版本出来。”</p></blockquote><p>确实，很多人都可以在黑客马拉松（hackathon）中建一个小工具，但是维护一个项目比建立一个项目要困难得多。开源项目维护者不仅仅需要写代码，更多时候还需要：</p><ul><li>写项目文档；</li><li>检查 Pull Request；</li><li>看看大家提的 Issue；</li><li>为项目增加新功能；</li><li>在 Stack Overflow 等平台回答关于本项目的问题；</li><li>在 QQ、微信等用户群里和用户讨论，回答问题。</li></ul><p>一个开源项目维护者必须一年到头无偿地做这么多复杂繁琐的工作。</p><h2 id="当我们很方便的使用开源项目时，太容易忘记项目维护者的辛苦付出了"><a href="#当我们很方便的使用开源项目时，太容易忘记项目维护者的辛苦付出了" class="headerlink" title="当我们很方便的使用开源项目时，太容易忘记项目维护者的辛苦付出了"></a>当我们很方便的使用开源项目时，太容易忘记项目维护者的辛苦付出了</h2><p>我们如何使用一个开源项目：</p><ol><li>我们在网上搜索遇到的问题的解决方案；</li><li>在一些博客和其他网站上进行搜索；</li><li>我们点击这个开源项目的链接，读项目的 README。安装并进行测试。哈哈哈，问题解决了！</li><li>我们转而看向了遇到的下一个问题。</li></ol><p>开源项目就像水和空气一样，人们只是享受它带来的好处并且习以为常。我们不会对空气或水说感谢，因为我们不知道那是谁造的。但是我们知道是谁创建了这些非常棒的开源项目。但是我们知道这么棒的开源项目是谁维护的啊。</p><h2 id="项目维护者们并不在意这些"><a href="#项目维护者们并不在意这些" class="headerlink" title="项目维护者们并不在意这些"></a>项目维护者们并不在意这些</h2><blockquote><p>开源项目使用者可能会想：</p><p>“他们不需要这些，他们需要的是 pull request 和能够修复 bug 等实质性工作。”</p><p>“我想他们更喜欢收到捐款。”</p></blockquote><p>但是他们真的很在意，<a href="https://news.ycombinator.com/item?id=15623604" target="_blank" rel="noopener">有时候，开源项目维护者真的需要你对他说一声谢谢</a>。当然，如果你能为项目捐款再好不过了，但是我知道的大多数开源项目维护者目的并不是赚钱。他们最终可能赚了钱，但与开发项目的动机相比，顶多算是一个副产品。我注意到，开源项目常常比非开源项目要好。因为最出色的开发者是出于激情和利他主义来开发产品的。如果你没能力或者不想捐钱，你可以给他们写句感谢的话。</p><h2 id="我们真的太“忙”了"><a href="#我们真的太“忙”了" class="headerlink" title="我们真的太“忙”了"></a>我们真的太“忙”了</h2><blockquote><p>“我们正在用双手改变世界。”</p><p>“我的项目必须在一周内启动。”</p><p>“我们每天都有数百封邮件需要回复。”</p><p>“我们只是没有时间。”</p></blockquote><p>这些开源项目有更大的潜力去改变世界；或许其中的哪个项目已经改变了世界。</p><blockquote><p>Github 在 Ruby 上使用 Rails<br>Instagram 使用 django<br>我们很多服务器都在运行着 Linux</p></blockquote><p>可能没有这些开源项目就没有我们现在的这些项目。</p><p>十分钟，你可能做不了什么大事。现在社交媒体让我们养成了一种习惯，就是更愿意点击一个 upvote 或者类似的按钮，而不是花十分钟来写一封感谢信。尽管一个好的开源项目可能节省了不仅仅十分钟的时间。我在 ProductHunt 上公开 <a href="https://www.thankyouopensource.com" target="_blank" rel="noopener">www.thankyouopensource.com</a> 这个网站后，很多用户抱怨最低 300 个字符的限制条件。我设置这个条件是想避免像下面这样简单的话：</p><blockquote><p>“谢谢，你们太棒了。”</p><p>“非常感谢。”</p><p>“我很喜欢你的开源项目。”</p></blockquote><p>我就得这些用户太“忙”了，没空写一封感谢信。但是这对我来说看起来像没有意义的垃圾邮件，我认为读这些就是在浪费时间。我们希望看到的感谢信是处于自愿的而不是义务的。这之间的不同对我们来说显而易见。我们希望维护者们知道我们为什么感谢他们的付出，他们的项目怎么帮助了我们，我们这些发自内心的感谢也是维护者们继续付出的强大动力之一。最重要的是，我们欢迎所有对维护项目感兴趣的人的加入，因为这确实是一件很棒的工作。一旦你成为了维护者，你会在感谢心中看到很多人对你付出的真诚的感谢。我建议在 GitHub 上加一个 <strong>感谢</strong> 的标签，不仅仅是感谢和激励维护者，更是邀请更多的人加入到其中。</p><h2 id="最后的一点想法"><a href="#最后的一点想法" class="headerlink" title="最后的一点想法"></a>最后的一点想法</h2><p>开源项目维护者是我们交朋友的好选择，也是公司雇佣员工时的明智之选。他们有激情，愿意分享，能够坚持。他们是真正的 MVP，他们应该得到真诚的感谢。</p><h2 id="什么是-Thank-you-open-source-🎉"><a href="#什么是-Thank-you-open-source-🎉" class="headerlink" title="什么是 Thank you, open source 🎉"></a>什么是 <a href="https://www.thankyouopensource.com" target="_blank" rel="noopener">Thank you, open source</a> 🎉</h2><p>这是一个非官方的，为大家向开源项目作者和维护者表达感谢的平台。同时它还为项目维护者们宣传其他项目提供了一个平台 🤙 </p><hr><blockquote><ul><li>原文地址：<a href="https://www.codementor.io/windsonyang/why-we-never-thank-open-source-maintainers-ed0nsw3zd" target="_blank" rel="noopener">Why we never thank open source maintainers</a></li><li>原文作者：<a href="https://www.codementor.io/windsonyang" target="_blank" rel="noopener">Windson Yang</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>译者：<a href="https://leviding.com" target="_blank" rel="noopener">LeviDing</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你现在可以到 &lt;a href=&quot;https://www.thankyouopensource.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Thank you, open source&lt;/a&gt; 这个网站上为你最喜欢的开源项目写一句感谢的话了。&lt;/p&gt;
&lt;p&gt;下面是我对为什么我们从来不去感谢开源项目维护者的一些看法。&lt;/p&gt;
    
    </summary>
    
      <category term="文章翻译" scheme="https://www.dingxuewen.com/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="译文" scheme="https://www.dingxuewen.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="开源" scheme="https://www.dingxuewen.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>让微信为你戴上圣诞帽的正确姿势</title>
    <link href="https://www.dingxuewen.com/article/how-to-let-wechat-wear-christmas-hat-words-for-me/"/>
    <id>https://www.dingxuewen.com/article/how-to-let-wechat-wear-christmas-hat-words-for-me/</id>
    <published>2017-12-23T04:00:00.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>就在昨天，你就可以通过发一条 @微信官方 的朋友圈来为自己戴上专属的圣诞帽啦。你一定看到很多朋友通过这种方式为自己戴上了圣诞帽吧，是不是很炫酷！在圣诞节来临之际，赶紧为自己也戴上一顶圣诞帽吧 😎</p><a id="more"></a><p>但是你可能发现，为什么我也像朋友那样发了一条 @微信官方 的朋友圈，但是我等了很长时间还是没有圣诞帽呢 😭 </p><p><img src="https://i.loli.net/2017/12/25/5a4076d5105da.jpg" alt></p><p>那应该就是你的姿势不对，没有触发到自动戴圣诞帽程序，下面我就告诉你让微信为你戴上圣诞帽的正确姿势：</p><ol><li>你发的朋友圈中必须要 @微信官方，不能是 @微信官网，也不是 @微信团队，更不能是 @微信，这样都是不能触发程序的；</li><li>你发的朋友圈中必须包含『请给我一顶圣诞帽』这几个字，一个字都不能落下。</li></ol><p>是不是挺麻烦的，那我就给你举个例子，你可以直接复制发朋友圈，让微信为你戴圣诞帽咯</p><blockquote><p>祝福语 + 请给我一顶圣诞帽 @微信官方<br>例子：圣诞快乐，请给我一顶圣诞帽 @微信官方</p></blockquote><p>现在你明白了吧，是不是很简单啊，赶紧复制上面的例子发送朋友圈，为自己戴上圣诞帽吧 😋</p><p>什么？没反应？你要等两分钟啊，戴帽子需要一些时间的，毕竟用户量这么大。</p><p><img src="https://i.loli.net/2017/12/25/5a4076ed7bc35.jpg" alt></p><p>什么？还是不行？是不是复制错了啊，再检查检查吧 😧</p><p><img src="https://i.loli.net/2017/12/25/5a4076fb895e9.jpg" alt></p><p>你说啥？还是不行？</p><p><img src="https://i.loli.net/2017/12/23/5a3e1995af70a.jpg" alt></p><p>能行就怪了，上面我都是骗你的 😳</p><p>那为啥我朋友 @微信官方 就戴上了圣诞帽？那只能说明他是骗你的，他提前 P 好了戴帽子的头像，发完朋友圈以后手动换了头像 😂</p><p>哈哈哈，开个玩笑，提前祝大家圣诞快乐 👏 </p><hr><blockquote><p><strong>想要圣诞帽的同学</strong>，关注微信公众号『LeviDing』，点击本文同名文章的 <strong>阅读原文</strong> 即可为自己 戴上一顶圣诞帽 吧，不要用回来打我 🤣<br>在公众号后台回复『圣诞』即可获得 <strong>专属圣诞帽表情包</strong>，快来试试吧 🤣 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在昨天，你就可以通过发一条 @微信官方 的朋友圈来为自己戴上专属的圣诞帽啦。你一定看到很多朋友通过这种方式为自己戴上了圣诞帽吧，是不是很炫酷！在圣诞节来临之际，赶紧为自己也戴上一顶圣诞帽吧 😎&lt;/p&gt;
    
    </summary>
    
      <category term="有趣好玩" scheme="https://www.dingxuewen.com/categories/%E6%9C%89%E8%B6%A3%E5%A5%BD%E7%8E%A9/"/>
    
    
      <category term="微信" scheme="https://www.dingxuewen.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="热点" scheme="https://www.dingxuewen.com/tags/%E7%83%AD%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 插件开发之 mainfest.json</title>
    <link href="https://www.dingxuewen.com/article/mainfest-json-for-chrome-plugin-development/"/>
    <id>https://www.dingxuewen.com/article/mainfest-json-for-chrome-plugin-development/</id>
    <published>2017-09-28T11:03:22.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome 作为目前最流行的浏览器，备受前端推崇，原因除了其对于前端标准的支持这一大核心原因之外，还有就是其强大的扩展性，基于其开发规范实现的插件如今已经非常庞大，在国内也是欣欣向荣，如天猫开发了大量的扩展，用于检测页面质量以及页面性能，淘宝开发了许多的扩展以供运营工具的优化等等。其强大性不言而喻。</p><a id="more"></a><p>与 Chrome 应用类似，Chrome 扩展主要是用于扩充 Chrome 浏览器的功能。他体现为一些文件的集合，包括前端文件（HTML/CSS/JS），配置文件 manifest.json。主要采用 JavaScript 语言进行编写。个别扩展可能会用到 DLL 和 SO 动态库，不过出于安全以及职责分离的考虑，在后续的标准中，将会被舍弃，这里不再赘述。</p><p>Chrome 扩展能做的事情：</p><ul><li>基于浏览器本身窗口的交互界面</li><li>操作用户页面：操作用户页面里的 DOM</li><li>管理浏览器：书签，cookie，历史，扩展和应用本身的管理，其中甚至修改 Chrome 的一些默认页面，地址栏关键字等，包括浏览器外观主题都是可以更改的</li></ul><blockquote><p>这里需要着重提一下，前端开发者喜欢的 DevTools 工具，在这里也能进行自定义</p></blockquote><ul><li>网络通信：http，socket，UDP/TCP 等</li><li>跨域请求不受限制：</li><li>常驻后台运行</li><li>数据存储：采用3种方式（localStorage，Web SQL DB，Chrome 提供的存储 API（文件系统））</li><li>扩展页面间可进行通信：提供 runtime 相关接口</li><li>其他功能：下载、代理、系统信息、媒体库、硬件相关（如 usb 设备操作，串口通信等）和国际化</li></ul><p>上面转自 <a href="https://github.com/kaola-fed/blog/issues/25" target="_blank" rel="noopener">Chrome 插件开发简介（一）——开发入门</a>本文就记录下开发插件必备的 mainfest.json 的相关知识，以备后用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Required 必须要求部分</span></span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,  <span class="comment">// manifest 版本从 chrome 18 之后都应该是 2, 此处不需要变化 </span></span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"My Extension"</span>, <span class="comment">// 名字是插件主要的 identifier</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.3"</span>, </span><br><span class="line">    <span class="comment">// 插件版本号, string, 最多为4个以 dot 分开的 interger, e.g. "3.1.2.4567"</span></span><br><span class="line">    <span class="comment">// 版本号不能随意乱写, chrome 的自动更新系统会根据版本号判断是否需要将插件更新至新的版本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recommended</span></span><br><span class="line">  <span class="attr">"default_locale"</span>: <span class="string">"en"</span>,</span><br><span class="line">    <span class="comment">// 如果需要指定不同 locale 使用不同的资源文件, 例如在中国显示中文, 在日本显示为日语等</span></span><br><span class="line">    <span class="comment">// 则会在根目录中添加 `_locale` 文件夹;</span></span><br><span class="line">    <span class="comment">// 若没有 `_locale` 文件夹, 则不能出现该项配置</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A plain text description"</span>, </span><br><span class="line">    <span class="comment">// 描述插件是干啥的, 描述需要适合在 chrome web store 上显示</span></span><br><span class="line">  <span class="attr">"icons"</span>: &#123;</span><br><span class="line">      <span class="attr">"16"</span>: <span class="string">"icon16.png"</span>,</span><br><span class="line">      <span class="attr">"48"</span>: <span class="string">"icon48.png"</span>,</span><br><span class="line">      <span class="attr">"128"</span>: <span class="string">"icon128.png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">// 图标可以是1个, 或者多个</span></span><br><span class="line">    <span class="comment">// 一般来说最好的方案是提供3个: </span></span><br><span class="line">    <span class="comment">// - 128x128: 在从 chrome web store 安装的过程中需要使用, Required</span></span><br><span class="line">    <span class="comment">// - 48x48: chrome://extensions 插件管理页面中使用</span></span><br><span class="line">    <span class="comment">// - 16x16: 插件页面当做 favicon 使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick one (or none) - browser_action / page_action</span></span><br><span class="line">  <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">      <span class="attr">"default_icon"</span>: &#123;                    <span class="comment">// optional</span></span><br><span class="line">        <span class="attr">"16"</span>: <span class="string">"images/icon16.png"</span>,           <span class="comment">// optional</span></span><br><span class="line">        <span class="attr">"24"</span>: <span class="string">"images/icon24.png"</span>,           <span class="comment">// optional</span></span><br><span class="line">        <span class="attr">"32"</span>: <span class="string">"images/icon32.png"</span>            <span class="comment">// optional</span></span><br><span class="line">      &#125;,</span><br><span class="line">        <span class="comment">// icon 是随意提供多少个, chrome 选取最接近的尺寸, 为了适配不同屏幕, 提供多种尺寸是很实用的</span></span><br><span class="line">      <span class="attr">"default_title"</span>: <span class="string">"Google Mail"</span>,      <span class="comment">// optional; shown in tooltip</span></span><br><span class="line">        <span class="comment">// tooltip, 光标停留在 icon 上时显示</span></span><br><span class="line">      <span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span>        <span class="comment">// optional</span></span><br><span class="line">        <span class="comment">// 如果有 popup 的页面, 则用户点击图标就会渲染此 HTML 页面</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">// 参考 https://developer.chrome.com/extensions/browserAction</span></span><br><span class="line">    <span class="comment">// 如果有 browser_action, 即在 chrome toolbar 的右边添加了一个 icon</span></span><br><span class="line">  </span><br><span class="line">  "page_action": &#123;...&#125;,</span><br><span class="line">    <span class="comment">// 如果并不是对每个网站页面都需要使用插件, 可以使用 page_action 而不是 browser_action</span></span><br><span class="line">    <span class="comment">// browser_action 应用更加广泛</span></span><br><span class="line">    <span class="comment">// 如果 page_action 并不应用在当前页面, 会显示灰色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional</span></span><br><span class="line">  "author": ...,</span><br><span class="line">  "automation": ...,</span><br><span class="line">  "background": &#123;</span><br><span class="line">    "scripts": ["background.js"],</span><br><span class="line">    <span class="comment">// "page": "background.html", // 如果有必要, 也可以指定 background HTML</span></span><br><span class="line">    "persistent": false // Recommended</span><br><span class="line">        <span class="comment">// 此处设定为 false 为如果这个 process 并没有在运行, 即释放内存和系统资源</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">// 参考: https://developer.chrome.com/extensions/background_pages</span></span><br><span class="line">    <span class="comment">// 如字面意思, background 即插件后台 process, 一般不需要 html, 只需要一个 js 文件, 类似一个监听器</span></span><br><span class="line">    <span class="comment">// 如果在 browser_action 或者其他情况下 state 变化, 就会告诉 background 来更新 view</span></span><br><span class="line">  "background_page": ...,</span><br><span class="line">  "chrome_settings_overrides": &#123;</span><br><span class="line">    "homepage": "http://www.homepage.com",</span><br><span class="line">    "search_provider": &#123;</span><br><span class="line">        "name": "name.__MSG_url_domain__",</span><br><span class="line">        "keyword": "keyword.__MSG_url_domain__",</span><br><span class="line">        "search_url": "http://www.foo.__MSG_url_domain__/s?q=&#123;searchTerms&#125;",</span><br><span class="line">        "favicon_url": "http://www.foo.__MSG_url_domain__/favicon.ico",</span><br><span class="line">        "suggest_url": "http://www.foo.__MSG_url_domain__/suggest?q=&#123;searchTerms&#125;",</span><br><span class="line">        "instant_url": "http://www.foo.__MSG_url_domain__/instant?q=&#123;searchTerms&#125;",</span><br><span class="line">        "image_url": "http://www.foo.__MSG_url_domain__/image?q=&#123;searchTerms&#125;",</span><br><span class="line">        "search_url_post_params": "search_lang=__MSG_url_domain__",</span><br><span class="line">        "suggest_url_post_params": "suggest_lang=__MSG_url_domain__",</span><br><span class="line">        "instant_url_post_params": "instant_lang=__MSG_url_domain__",</span><br><span class="line">        "image_url_post_params": "image_lang=__MSG_url_domain__",</span><br><span class="line">        "alternate_urls": [</span><br><span class="line">          "http://www.moo.__MSG_url_domain__/s?q=&#123;searchTerms&#125;",</span><br><span class="line">          <span class="string">"http://www.noo.__MSG_url_domain__/s?q=&#123;searchTerms&#125;"</span></span><br><span class="line">        ],</span><br><span class="line">        "encoding": "UTF-8",</span><br><span class="line">        "is_default": true</span><br><span class="line">    &#125;,</span><br><span class="line">    "startup_pages": ["http://www.startup.com"]</span><br><span class="line">  &#125;, // 覆盖 chrome 设定, Homepage, Search Provider, and Startup Pages</span><br><span class="line">  "chrome_ui_overrides": &#123;</span><br><span class="line">    "bookmarks_ui": &#123;</span><br><span class="line">      "remove_bookmark_shortcut": true, // 去掉添加书签的快捷键, </span><br><span class="line">      "remove_button": true // 去掉了地址栏右边的 star button, 可以将 browser_action 的 icon 放在此处</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, // 覆盖 bookmark ui 设置, 需要 Chrome Dev Release, 较新的 api 吧</span><br><span class="line">  "chrome_url_overrides": &#123;</span><br><span class="line">    "pageToOverride": "myPage.html"</span><br><span class="line">      <span class="comment">// 替换页面 HTML/CSS/JS, 可以替换的页面: </span></span><br><span class="line">      <span class="comment">// - 书签管理页面 chrome://bookmarks</span></span><br><span class="line">      <span class="comment">// - 浏览历史页: chrome://history</span></span><br><span class="line">      <span class="comment">// - 新标签页: chrome://newtab </span></span><br><span class="line">  &#125;,</span><br><span class="line">  "commands": &#123;</span><br><span class="line">      <span class="comment">// commands API 用来添加快捷键</span></span><br><span class="line">      <span class="comment">// 需要在 background page 上添加监听器绑定 handler</span></span><br><span class="line">    "toggle-feature-foo": &#123;</span><br><span class="line">      "suggested_key": &#123;</span><br><span class="line">        "default": "Ctrl+Shift+Y",</span><br><span class="line">        "mac": "Command+Shift+Y"</span><br><span class="line">      &#125;,</span><br><span class="line">      "description": "Toggle feature foo",</span><br><span class="line">      "global": true</span><br><span class="line">        <span class="comment">// 当 chrome 没有 focus 时也可以生效的快捷键</span></span><br><span class="line">        <span class="comment">// 仅限 Ctrl+Shift+[0..9]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    "_execute_browser_action": &#123;</span><br><span class="line">      "suggested_key": &#123;</span><br><span class="line">        "windows": "Ctrl+Shift+Y",</span><br><span class="line">        "mac": "Command+Shift+Y",</span><br><span class="line">        "chromeos": "Ctrl+Shift+U",</span><br><span class="line">        "linux": "Ctrl+Shift+J"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "_execute_page_action": &#123;</span><br><span class="line">      "suggested_key": &#123;</span><br><span class="line">        "default": "Ctrl+Shift+E",</span><br><span class="line">        "windows": "Alt+Shift+P",</span><br><span class="line">        "mac": "Alt+Shift+P"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  "content_capabilities": ...,</span><br><span class="line">    <span class="comment">// content_scripts 是在当前网页中插入并执行的脚本, 可以对网页进行各种操作</span></span><br><span class="line">    <span class="comment">// content_scripts 中可以监听插件发来的 message, 并进行某些操作</span></span><br><span class="line">    <span class="comment">// 可以选择是否永远插入, 或者只在一部分网页中 inject</span></span><br><span class="line">    <span class="comment">// content_scripts 执行环境称为 isolated world, 和正常页面中的 JS 不在相同环境中</span></span><br><span class="line">    <span class="comment">//  保证不同 script 不会冲突, 也不会和网页本身冲突</span></span><br><span class="line">    <span class="comment">//  也说明互相无法访问或使用其中的变量或函数</span></span><br><span class="line">  "content_scripts": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"matches"</span>: [<span class="string">"http://www.google.com/*"</span>],</span><br><span class="line">        <span class="comment">// 指定那些页面需要 inject </span></span><br><span class="line">      <span class="attr">"css"</span>: [<span class="string">"mystyles.css"</span>], <span class="comment">// 按照顺序 inject</span></span><br><span class="line">      <span class="attr">"js"</span>: [<span class="string">"jquery.js"</span>, <span class="string">"myscript.js"</span>], <span class="comment">// 按照顺序 inject</span></span><br><span class="line">      <span class="attr">"run_at"</span>: <span class="string">"document_idle"</span>, <span class="comment">// 什么时候 inject js,  "document_start", "document_end", or "document_idle".</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "content_security_policy": "policyString",</span><br><span class="line">    <span class="comment">// https://developer.chrome.com/extensions/contentSecurityPolicy</span></span><br><span class="line">  "converted_from_user_script": ...,</span><br><span class="line">  "current_locale": ...,</span><br><span class="line">  "devtools_page": "devtools.html",</span><br><span class="line">    <span class="comment">// 对 DevTools 的扩展, 例如 React, Redux develop tools</span></span><br><span class="line">  "event_rules": [&#123;...&#125;],</span><br><span class="line">    <span class="comment">// 添加规则将某些 JS 事件转为 manifest (?)</span></span><br><span class="line">  "externally_connectable": &#123;</span><br><span class="line">    <span class="comment">// 指定哪些插件/ app/ 网站可以连接到你的插件上</span></span><br><span class="line">    <span class="comment">// 此处 ids 指允许连接的其他插件 id</span></span><br><span class="line">    <span class="comment">// 注意: 如果不写, 则认为所有其他插件都不能连接</span></span><br><span class="line">    "ids": [</span><br><span class="line">      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",</span><br><span class="line">      "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 使用 wildcard "*" 允许所有其他插件连接</span></span><br><span class="line">      <span class="string">"*"</span></span><br><span class="line">    ],</span><br><span class="line">    "matches": ["*://*.example.com/*"]</span><br><span class="line">  &#125;,</span><br><span class="line">  "file_browser_handlers": [...], // 仅能在 Chrome OS 上使用, 对文件的操作</span><br><span class="line">  "file_system_provider_capabilities": &#123;</span><br><span class="line">    <span class="comment">// 仅能在 Chrome OS 上使用, 对文件的操作</span></span><br><span class="line">    "configurable": true,</span><br><span class="line">    "multiple_mounts": true,</span><br><span class="line">    "source": "network"</span><br><span class="line">  &#125;,</span><br><span class="line">  "homepage_url": "http://path/to/homepage",</span><br><span class="line">  "import": [&#123;"id": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"&#125;],</span><br><span class="line">    <span class="comment">// 如果有 shared module, 在提供 shared module 的 extension 中则会有 "export" 项</span></span><br><span class="line">  "incognito": "spanning, split, or not_allowed",</span><br><span class="line">    <span class="comment">// 隐身模式下, "spanning" -&gt; chrome app, "split" -&gt; ext</span></span><br><span class="line">  "input_components": ...,</span><br><span class="line">  "key": "publicKey", // 不怎么需要用到了</span><br><span class="line">  "minimum_chrome_version": "versionString", // 与 version 相同</span><br><span class="line">  "nacl_modules": [&#123;</span><br><span class="line">    "path": "OpenOfficeViewer.nmf",</span><br><span class="line">    "mime_type": "application/vnd.oasis.opendocument.spreadsheet"</span><br><span class="line">  &#125;], // 使用 Native Client Module 对网络上某种 MIME 类似资源进行操作, 但貌似 deprecated 了, 往 WebAssembly发展了 </span><br><span class="line">  "oauth2": ...,</span><br><span class="line">  "offline_enabled": true,</span><br><span class="line">  "omnibox": &#123;</span><br><span class="line">    "keyword": "aString"</span><br><span class="line">    <span class="comment">// 注册一个 keyword显示在 address bar 的前面</span></span><br><span class="line">    <span class="comment">// 当用户在 address bar 中输入 keyword 后, 用户就是和插件在交互了</span></span><br><span class="line">  &#125;,</span><br><span class="line">  "optional_permissions": ["tabs"], // 其他需要的 permission, 在使用 chrome.permissions API 时用到, 并非安装插件时需要</span><br><span class="line">  "options_page": "options.html",</span><br><span class="line">    <span class="comment">// 允许用户进行某些配置来定制插件功能, 并使用 chrome.storage.sync api 来保存设置 </span></span><br><span class="line">  "options_ui": &#123;</span><br><span class="line">    "chrome_style": true, //默认使用 Chrome user agent stylesheet</span><br><span class="line">    "page": "options.html",</span><br><span class="line">    "open_in_tab": false // 不建议打开新 tab, 以后会删除此项</span><br><span class="line">  &#125;, // 新版配置功能 api, 支持 chrome40 以上, 打开 dialogue, 使用 chrome.runtime.openOptionsPage api 打开 option 页面</span><br><span class="line">  "permissions": ["tabs"],</span><br><span class="line">    <span class="comment">//-&gt; https://developer.chrome.com/extensions/declare_permissions</span></span><br><span class="line">    <span class="comment">// 有很多选择, 书签/右键菜单/剪贴板/cookie/下载/.... 等</span></span><br><span class="line">  "platforms": ...,</span><br><span class="line">  "plugins": [...],</span><br><span class="line">  "requirements": &#123;</span><br><span class="line">    "3D": &#123;</span><br><span class="line">      "features": ["webgl"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, // 要求某些可能需要用户安装某些额外的 tech, 例如 webGL</span><br><span class="line">  "sandbox": [...], // chrome 57 以上不再允许外部 web 内容</span><br><span class="line">  "short_name": "Short Name", // 插件名字简写</span><br><span class="line">  "signature": ...,</span><br><span class="line">  "spellcheck": ...,</span><br><span class="line">  "storage": &#123;</span><br><span class="line">    "managed_schema": "schema.json"</span><br><span class="line">  &#125;, //  使用 storage.managed api 的话, 需要一个 schema 文件指定存储字段类型等, 类似定义数据库表的 column</span><br><span class="line">  "system_indicator": ...,</span><br><span class="line">  "tts_engine": &#123;</span><br><span class="line">    "voices": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"voice_name"</span>: <span class="string">"Alice"</span>,</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"en-US"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>: <span class="string">"female"</span>,</span><br><span class="line">        <span class="attr">"event_types"</span>: [<span class="string">"start"</span>, <span class="string">"marker"</span>, <span class="string">"end"</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"voice_name"</span>: <span class="string">"Pat"</span>,</span><br><span class="line">        <span class="attr">"lang"</span>: <span class="string">"en-US"</span>,</span><br><span class="line">        <span class="attr">"event_types"</span>: [<span class="string">"end"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;, // text-to-speech(TTS) engine, permission 需要加上 ttsEngine</span><br><span class="line">  "update_url": "http://path/to/updateInfo.xml", // 如果不是通过 chrome web store 自动更新插件</span><br><span class="line">  "version_name": "aString", // 版本号名称, 如 "1.0 beta", 只是为了展示, 更加描述性</span><br><span class="line">  "web_accessible_resources": [...] </span><br><span class="line">    <span class="comment">// 提供插件pkg中某些资源是当前 web page 可以使用的</span></span><br><span class="line">    <span class="comment">// 默认插件中的资源对于网页是 blocked, 需要说明哪些是要使用的 图片/图标/css/js 等 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chrome 作为目前最流行的浏览器，备受前端推崇，原因除了其对于前端标准的支持这一大核心原因之外，还有就是其强大的扩展性，基于其开发规范实现的插件如今已经非常庞大，在国内也是欣欣向荣，如天猫开发了大量的扩展，用于检测页面质量以及页面性能，淘宝开发了许多的扩展以供运营工具的优化等等。其强大性不言而喻。&lt;/p&gt;
    
    </summary>
    
      <category term="项目实战" scheme="https://www.dingxuewen.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Chrome" scheme="https://www.dingxuewen.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>译文：学习 JavaScript：阻碍你进步的 9 个常见错误</title>
    <link href="https://www.dingxuewen.com/article/learning-javascript-9-common-mistakes/"/>
    <id>https://www.dingxuewen.com/article/learning-javascript-9-common-mistakes/</id>
    <published>2017-09-17T05:57:44.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>很多人尝试学习 JavaScript ，但是不久就放弃了。然后他们就告诉自己，“JavaScript 太复杂了”，更有甚者说，“我不是前端开发的料”。这种情况挺让人悲伤的。其实根本不必放弃，所要做的仅仅是换一种不同的学习方法。</p><a id="more"></a><p>在这篇文章中，我们将介绍一些最常见的错误学习方法，并了解如何避免这些错误。许多技巧不仅适用于 JavaScript，甚至可以用到 web 开发上，所以也算是一种福利。</p><p>我们来吧！</p><h2 id="错误-1：开始学习之前过度分析"><a href="#错误-1：开始学习之前过度分析" class="headerlink" title="错误 #1：开始学习之前过度分析"></a>错误 #1：开始学习之前过度分析</h2><p>开始学习 JavaScript 之前，你可以找到很多相关的信息。如果你去看，就会发现一些 JavaScript 是最好的或者是最坏的、你是需要这个框架还那个框架的相关信息。你也可能会听到你需要以某种方式编写 JavaScript，否则你永远不会成为“真正”的开发人员等。</p><p>不管这些说的正确与否，没有什么比浪费六个月到一年还没有开始更糟糕。</p><p>开始敲代码吧，它不一定完美，可能很糟糕。但如果你开始了，就通过了阻碍很多人的障碍之一了。</p><h2 id="错误-2：学习原生-JavaScript-之前学习框架"><a href="#错误-2：学习原生-JavaScript-之前学习框架" class="headerlink" title="错误 #2：学习原生 JavaScript 之前学习框架"></a>错误 #2：学习原生 JavaScript 之前学习框架</h2><p>JavaScript 框架建立在原生 JavaScript 之上，因此如果你理解了 JavaScript，你也就自然而然的知道如何使用任何 JavaScript 框架的基本原理。</p><p>然而，如果你直接学习一个框架，最后也只是记住了它的语法却不理解它的原理。这就像在不知道词语意思的情况下造句，最终你只是随便地记住了一些词语，却不知道这些词语的意思并且不会组织这些词语来学以致用。</p><p>如果你直接进入一个框架，那将会更难学习，当你需要另一个框架你会更难适应。如果你首先学习基础的 JavaScript，那么你将有一个坚实的基础来了解所有的框架。</p><h2 id="错误-3：好高骛远"><a href="#错误-3：好高骛远" class="headerlink" title="错误 #3：好高骛远"></a>错误 #3：好高骛远</h2><p>最常见的错误之一就是在理解概念之后立即采取行动。</p><p>我一直在努力解决这个问题，因为一旦了解某些东西，你就想更进一步。</p><p>像对待新玩具一样对待每个概念是很有帮助的；这意味着你需要花一些时间来享受你刚学到的东西。玩耍、实验，看看你能不能做一些新的事情。你会学到很多，你会记得更好。</p><p>当你感觉自己闭着眼睛都能运用自如的时候再继续向下学习。可能在达到这一步之前，你需要更多的时间，但是这将是你接下来的学习变得更快。</p><p>另一方面，如果你过于急躁，你就不会太注意细节。但令人沮丧的是，这会使你之后的学习成本大幅提升。其实这也是人们常说要放弃学习 JavaScript 的常见原因之一。</p><h2 id="错误-4：没有将概念理解透彻"><a href="#错误-4：没有将概念理解透彻" class="headerlink" title="错误 #4：没有将概念理解透彻"></a>错误 #4：没有将概念理解透彻</h2><p>学习就像爬楼梯：如果你能走一步，你可以继续采取更多的步骤，直到你达到目标。当有些东西难以理解时，往往是因为你想要进行一次飞跃，而不是一次走一步。当然这是痴心妄想！</p><p>在实际场景中，我看到人们对某段代码不理解的时候，我会请他们解释一下，他们会试图一下解释清整个问题。那我会请他们再一行一行的解释一遍，这样是有道理的。</p><p>如果有些部分很让人费解，那经常是因为跳过了某些东西，那么这也将有助于你去关注细节，直到找出症结所在。如果一个概念在分解之后仍然没有意义，那你也会有更容易找到相关解决方法，因为查找特定的主题比胡乱搜索更容易。</p><h2 id="错误-5：太早尝试复杂的项目"><a href="#错误-5：太早尝试复杂的项目" class="headerlink" title="错误 #5：太早尝试复杂的项目"></a>错误 #5：太早尝试复杂的项目</h2><p>刚开始学习 JavaScript 的人经常会说“我就随便定个小目标，写一个 Facebook 那样的网站算了”，没有意识到项目所涉及的深度。当项目逐渐深入时，他们就放弃学习 JavaScript 了。</p><p>我更详细地介绍了<a href="https://www.sitepoint.com/projects-can-sometimes-be-the-worst-way-to-learn-javascript/" target="_blank" rel="noopener">关于项目</a>，但是在学习的时候，从一些基本概念开始会更容易。当你开始做项目时，你可以在工具包中添加一些构建工具。</p><p>更明确地说，我不是要那种越旷日持久的项目。我刚刚发现，如果我先做了一些简单的部分，比如在浏览器中显示一些文本或响应一个按钮，那么就可以更轻松地启动项目。</p><h2 id="错误-6：不在真实环境下练习"><a href="#错误-6：不在真实环境下练习" class="headerlink" title="错误 #6：不在真实环境下练习"></a>错误 #6：不在真实环境下练习</h2><p>当你学习 JavaScript 时，你可能会在不符合真实环境下进行练习。例如，你可能在网站的内置代码编辑器中输入内容，或者你可能依赖于教程中的粘贴文件。</p><p>这些方法对于学习来说可能是非常好的，但是你也可以尝试自己搭建环境。这意味着使用你自己的文本编辑器，并从头开始编写项目。</p><p>如果你不自己独立练习每一个概念，那你会依赖于训练环境。你最终会遇到这样的情况：你已经花了很多时间来学习，但你一个都无法掌握。</p><h2 id="错误-7：将自己与大神进行比较"><a href="#错误-7：将自己与大神进行比较" class="headerlink" title="错误 #7：将自己与大神进行比较"></a>错误 #7：将自己与大神进行比较</h2><p>让自己更沮丧的最简单的方法之一就是和大神进行比较。因为你总是看他们在那里，而不是看他们如何到达那里。</p><p>举个例子，人们看到我的教程，并问我如何写这么干净的代码。他们说他们无法编写像这样的干净的代码，所以也许他们根本就不是 JavaScript 的那块料。</p><p>事实是我的过程是一团糟。我不断试验、犯错、查阅资料，写下丑陋的代码，最后把所有的内容都细化成一个可呈现的教程。人们看了优秀的版本，并且假设整个过程就是这样的。我也做过关于教程作者的这些假设，直到我开始写我自己的教程。</p><p>关键点是，认真学习你正在学习的东西，你会得到进步。继续重复这个过程，很快别人就会好奇你是如何达到那种高度的。</p><h2 id="错误-8：只看教程不写代码"><a href="#错误-8：只看教程不写代码" class="headerlink" title="错误 #8：只看教程不写代码"></a>错误 #8：只看教程不写代码</h2><p>你会自然而然的花费大量的时间来观看视频和教程，但是除非你自己动手编写代码，否则你不能真的学会。</p><p>光看而不采取实际行动是很危险的，你会有一种你正在学习的错觉。六个月后，你会发现自己什么都没学会。</p><p>写 15 分钟的代码比上你光看一小时的教程有用多了。</p><h2 id="错误-9：没有事先理解或自行尝试就盲目跟从教程"><a href="#错误-9：没有事先理解或自行尝试就盲目跟从教程" class="headerlink" title="错误 #9：没有事先理解或自行尝试就盲目跟从教程"></a>错误 #9：没有事先理解或自行尝试就盲目跟从教程</h2><p>阅读教程时，很容易陷入照葫芦画瓢的情况。这种教程并不会教你如何解决一个问题，例如需要进行怎样的测试，如何一步一步的探索可能出问题的方向。因此，只会跟着教程走的人往往学不到真正的知识。</p><p>那么解决方案是什么？</p><p>不要只知道跟着教程一步步走，而是要花点儿时间去自己实现。例如，如果您正在学习幻灯片教程，请尝试显示和隐藏 div，然后尝试计时，然后尝试另一个小部分。相对于跟着教程一步步地走，通过亲身尝试并拓展你将学到更多知识，并且有可能将它应用得更好。</p><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>在你读完这篇文章后，如果你问我最想让你记住什么，那就是通过采取最小的步骤来取得最大的进步。</p><p>无论你在学习什么，都要好好学习它本质上的东西。尝试你学到的东西，并乐在其中。</p><p>有时可能很困难，但这没关系。挑战意味着你正在提升个人能力，这将使你进步。如果一切总是太容易，这可能意味你需要进行些改变了。</p><p>我希望这篇文章对你有所帮助，如果有什么其他的帮助过你学习 JavaScript 的方法，欢迎你随时在评论中分享！</p><hr><blockquote><ul><li>原文地址：<a href="https://www.sitepoint.com/learning-javascript-9-common-mistakes/" target="_blank" rel="noopener">Learning JavaScript: 9 Common Mistakes That Are Holding You Back</a></li><li>原文作者：<a href="https://www.sitepoint.com/author/yberhanu/" target="_blank" rel="noopener">Yaphi Berhanu</a></li><li>翻译和校对：<a href="https://github.com/lekenny" target="_blank" rel="noopener">lekenny</a> <a href="https://github.com/lampui" target="_blank" rel="noopener">lampui</a> <a href="https://github.com/Yuuoniy" target="_blank" rel="noopener">Yuuoniy</a></li><li>审阅：<a href="http://www.dingxuewen.com">LeviDing</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人尝试学习 JavaScript ，但是不久就放弃了。然后他们就告诉自己，“JavaScript 太复杂了”，更有甚者说，“我不是前端开发的料”。这种情况挺让人悲伤的。其实根本不必放弃，所要做的仅仅是换一种不同的学习方法。&lt;/p&gt;
    
    </summary>
    
      <category term="文章翻译" scheme="https://www.dingxuewen.com/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="译文" scheme="https://www.dingxuewen.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="JavaScript" scheme="https://www.dingxuewen.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>记于 2017 年 9 月 11 日晚</title>
    <link href="https://www.dingxuewen.com/article/memories-of-the-past-in-2017/"/>
    <id>https://www.dingxuewen.com/article/memories-of-the-past-in-2017/</id>
    <published>2017-09-16T15:03:22.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>2017 年 9 月 11 日晚 9 点半，我正搭乘着 Z285 次列车，从北京西站赶往武昌。耳机里放着林俊杰的『爱笑的眼睛』。想想自己已经 22 岁了，已经是一名大四的老货了，感觉这几年眨眼间就过去了。</p><a id="more"></a><p>还记得 2008 年，自己选择了去吉林省延边第三中学读初中，独自一人远离我的小家，心里又些许的兴奋，但更多的是不舍。三年的半封闭式初中生活，让我成长很多，当然中间有犯过现在想起来很傻叉的错误，但想想谁的青春不烦错呢，也许正是这种不完美，才增添了生活的乐趣吧。</p><p>2011 年，我来到了我选择的吉林省延边第二高级中学读高中，这所学校是我现在想起来就满满自豪感的学校。哈哈哈，大家熟知的，锤子手机罗永浩，就是在这所学校读的高中，但是中途不念了。</p><p>2014 年阴差阳错，来到了现在就读的中国地质大学（武汉），有想过复读重考吗？根本没想过，高三那种生活我不想再经历第二次，不是身体累，而是心累。可以说，高三经历的那些让我成熟了不少。</p><p>2017 年 9 月，也就是此时此刻，回想大学四年的生活啊，我可以用六个字总结：不完美，不遗憾。</p><p>我曾经因为各种事交杂在一起而忙的要哭，路过没，哭过，被窝里自己哭啊，擦擦眼泪就成长了不是吗。我也曾经因为考试结束，感觉要挂科而心烦意乱，不对，我找不到词来形容那种感受了。我已经想好，如果挂了需要承受什么样的后果，做好了相应的打算，但庆幸最终的结果是好的，这也给我敲响了警钟。</p><p>当然，我也曾经因为获得一些奖励，一些荣誉而高兴，毕竟是自己努力获得的成果。我也摸清了学校一些比赛的套路，同时也对我总结的套路进行了实践，较为轻松的赢得了些比赛，套路是可以传授给身边的小师弟的，哈哈。</p><p>转眼间在北京实习已经一个月零五天了，学习到了一个公司是如何运作的，各个部门间大致是如何配合的等等。当然，还有很多需要学习的地方。希望我在公司的期间能够为公司创造些价值吧。</p><p>前段时间收获了第一笔做网站的几千块收入，不用和父母要钱换了个手机，还挺开心的。哈哈哈，很快就能经济独立了。</p><p>现在呢，我应该是选择保研了，对于这个决定，我不置可否。只希望自己能够不忘初心，努力朝着自己心中的方向努力前行。希望毕业能赚大钱，迎娶白富美，走向人生巅峰 『手动滑稽』。</p><p>明早就到武汉啦，再回去吃一碗热干面，喝一个豆浆，去游个泳。想想也是挺不错的呢。13 号晚上再坐车返京。</p><p>这时耳机里放着李健的『温暖』，哦对，他是我最喜欢的歌手之一呢。就这样睡吧，晚安。</p><p>记于 2017 年 9 月 11 日晚。</p><blockquote><p>后记，说好的回武汉吃热干面喝豆浆，我怎么就忘了呢！还好吃了周黑鸭。继续加油吧，小伙子。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 年 9 月 11 日晚 9 点半，我正搭乘着 Z285 次列车，从北京西站赶往武昌。耳机里放着林俊杰的『爱笑的眼睛』。想想自己已经 22 岁了，已经是一名大四的老货了，感觉这几年眨眼间就过去了。&lt;/p&gt;
    
    </summary>
    
      <category term="生活随想" scheme="https://www.dingxuewen.com/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="成长" scheme="https://www.dingxuewen.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="随想" scheme="https://www.dingxuewen.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>译文：用 -force 对项目有风险，用 -force-with-lease 命令代替吧</title>
    <link href="https://www.dingxuewen.com/article/force-with-lease/"/>
    <id>https://www.dingxuewen.com/article/force-with-lease/</id>
    <published>2017-07-30T15:03:22.000Z</published>
    <updated>2023-02-08T09:52:15.507Z</updated>
    
    <content type="html"><![CDATA[<p>Git 的 <code>push --force</code> 具有破坏性，因为它无条件地覆盖远程存储库，无论你在本地拥有什么。使用这个命令，可能覆盖团队成员在此期间推送的所有更改。然而，有一个更好的办法，当你需要强制推送，但仍需确保不覆盖其他人的工作时，<code>-force-with-lease</code> 这条指令选项可以帮助到你。</p><a id="more"></a><p>众所周知，git 的 <code>push -force</code> 指令是不推荐被使用的，因为它会破坏其他已经提交到共享库的内容。虽然这不总是完全致命的（如果那些修改的内容仍在某些同事的本地工作域中，那之后他们能被重新合并），但是这样的做法很欠考虑，最糟糕的情况会造成灾难性的损失。这是因为 <code>--force</code> 指令选项迫使分支的头指针指向你个人的修改记录，而忽略了那些其他和你同时进行地更改。</p><p>强制推动最常见的原因之一是当我们被迫 <code>rebase</code> 一个分支的时候。为了说明这一点，我们来看一个例子。我们有一个项目，其中有一个功能分支，Alice 和 Bob 要同时在这个分支上工作。他们都 <code>git clone...</code> 了这个仓库，并开始工作。</p><p>最初，Alice 完成了她负责的功能，并将其 <code>push</code> 到主仓库。这都没啥问题。</p><p>Bob 也完成了他的工作，但在 <code>push</code> 之前，他注意到一些变化已被合并到了 <em>master</em> 分支。想要保持一棵整洁的工作树，他会对主分支执行一个 <code>rebase</code>。当然，当他 <code>push</code> 这个经过 <code>rebase</code> 的分支的时候将被拒绝。然而，Bob 没有意识到 Alice 已经 <code>push</code> 了她的工作。Bob 执行了 <code>push --force</code> 命令。不幸的是，这将清除 Alice 在远程主仓库的所有更改和记录。</p><p>这里的问题是，进行强制推送的 Bob 不知道为什么他的 <code>push</code> 会被拒绝，所以他认为这是 <code>rebase</code> 造成的，而不是由于 Alice 的变化。这就是为什么 <code>--force</code> 在同一个分支上协作的时候要杜绝的；并且通过远程主仓库的工作流程，任何分支都可以被共享。</p><p>但是 <code>--force</code> 有一个不为众人所知的亲戚，它在<strong>一定程度上</strong>能防止强制更新操作带来的结构性破坏；它就是 <code>--force-with-lease</code>。</p><p><img src="https://developer.atlassian.com/blog/2015/04/force-with-lease/force-with-lease.jpg" alt="我不经常使用 push --force..."></p><p><code>--force-with-lease</code> 是用于拒绝更新一个分支，除非该分支达到我们期望的状态。即没有人在上游更新分支内容。 实际上，通过检查上游引用是我们所期望的，因为引用是散列，并将父系链隐含地编码成它们的值。</p><p>你可以告诉 <code>--force-with-lease</code> 究竟要检查什么，默认情况下会检查当前的远程引用。这在实践中意味着，当 Alice 更新她的分支并将其推送到远程仓库时，分支的引用指针将被更新。现在，除非 Bob从远程仓库 <code>pull</code> 一下，否则<em>本地</em>对远程仓库的引用将过期。当他使用 <code>--force-with-lease</code> 推送时，git 会检查本地与远程的引用是否对应，并拒绝 Bob 的强制推送。<code>--force-with-lease</code> 有效地只在没有人在上游更新分支内容的时候允许你强制推送。就像是一个带有安全带的 <code>--force</code>。它的一个快速演示可能有助于说明这一点：</p><p>Alice 已经对该分支进行了一些更改，并已推送到了远程主仓库。Bob 现在又对远程仓库的 <code>master</code> 分支进行了 <code>rebases</code> 操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: Dev commit <span class="comment">#1</span></span><br><span class="line">Applying: Dev commit <span class="comment">#2</span></span><br><span class="line">Applying: Dev commit <span class="comment">#3</span></span><br></pre></td></tr></table></figure><p><code>rebase</code> 之后，他试图将自己的更改 <code>push</code> 上去，但服务器拒绝了，因为这会覆盖 Alice 的工作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git push</span><br><span class="line">To /tmp/repo</span><br><span class="line"> ! [rejected]        dev -&gt; dev (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'/tmp/repo'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>但 Bob 认为这是 <code>rebase</code> 操作造成的，并决定强制 <code>push</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git push --force</span><br><span class="line">To /tmp/repo</span><br><span class="line"> + f82f59e...c27aff1 dev -&gt; dev (forced update)</span><br></pre></td></tr></table></figure><p>然而，如果他使用了 <code>--force-with-lease</code>，则会得到不同的结果，因为 git 会检查远程分支，发现 从上一次 Bob 使用 <code>fetch</code> 到现在，实际上并没有被更新：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git push -n --force-with-lease</span><br><span class="line">To /tmp/repo</span><br><span class="line"> ! [rejected]        dev -&gt; dev (stale info)</span><br><span class="line">error: failed to push some refs to <span class="string">'/tmp/repo'</span></span><br></pre></td></tr></table></figure><p>当然，在这有一些关于 git 的注意事项。上面展示的，只有当 Alice 已经将其更改推送到远程存储库时，它才有效。这不是一个严重的问题，但是如果她想修改她提交的东西，那她去 <code>pull</code> 分支时，会被提示合并被更改。</p><p>一个更微妙的问题是，我们有方法去骗 git，让 git 认为这个分支没有被修改。在正常使用情况下，最常发生这种现象的情况是，Bob 使用 <code>git fetch</code> <code>而不是</code>git pull<code></code>来更新他的本地副本。<code>fetch</code> 将从远程仓库拉出对象和引用，但没有匹配的 <code>merge</code> 则不会更新工作树。这将使本地仓库看起来已经与远程仓库进行了同步更新，但实际上本地仓库并没有进行更新，并欺骗 <code>--force-with-lease</code> 命令，成功覆盖远程分支，就像下面这个例子：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git push --force-with-lease</span><br><span class="line">To /tmp/repo</span><br><span class="line"> ! [rejected]        dev -&gt; dev (stale info)</span><br><span class="line">error: failed to push some refs to <span class="string">'/tmp/repo'</span></span><br><span class="line"></span><br><span class="line">ssmith$ git fetch</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From /tmp/repo</span><br><span class="line">   1a3a03f..d7cda55  dev        -&gt; origin/dev</span><br><span class="line"></span><br><span class="line">ssmith$ git push --force-with-lease</span><br><span class="line">Counting objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (9/9), 845 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 9 (delta 0), reused 0 (delta 0)</span><br><span class="line">To /tmp/repo</span><br><span class="line">   d7cda55..b57fc84  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>这个问题的最简单的答案就是，简单的说“不要在没有合并的情况下 <code>fetch</code> 远程该分支”（或者更常用的方法是 <code>pull</code>，这个操作包含了前面的两个），但是如果由于某种原因你希望在用 <code>--force-with-lease</code> 进行代码上传之前进行 <code>fetch</code>，那么这有一种比较安全的方法。像 git 那么多的属性一样，引用只是对象的指针，所以我们可以创建我们自己的引用。在这种情况下，我们可以在进行 <code>fetch</code> 之前，为远程仓库引用创建“保存点”的副本。然后，我们可以告诉 <code>--force-with-lease</code> 将此作为引用值，而不是已经更新的远程引用。</p><p>为了做到这一点，我们使用 git 的 <code>update-ref</code> 功能来创建一个新的引用，以保存远程仓库在任何 <code>rebase</code> 或 <code>fetch</code> 操作前的状态。这有效地标记了我们开始强制 <code>push</code> 到远程的工作节点。在这里，我们将远程分支 <code>dev</code> 的状态保存到一个名为 <code>dev-pre-rebase</code> 的新引用中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git update-ref refs/dev-pre-rebase refs/remotes/origin/dev</span><br></pre></td></tr></table></figure><p>这时呢，我们就可以进行 <code>rebase</code> 和 <code>fetch</code> 操作，然后使用保存的 <code>ref</code> 来保护远程仓库，以防有人在工作时做了更改：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssmith$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: Dev commit <span class="comment">#1</span></span><br><span class="line">Applying: Dev commit <span class="comment">#2</span></span><br><span class="line">Applying: Dev commit <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">ssmith$ git fetch</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From /tmp/repo</span><br><span class="line">   2203121..a9a35b3  dev        -&gt; origin/dev</span><br><span class="line"></span><br><span class="line">ssmith$ git push --force-with-lease=dev:refs/dev-pre-rebase</span><br><span class="line">To /tmp/repo</span><br><span class="line"> ! [rejected]        dev -&gt; dev (stale info)</span><br><span class="line">error: failed to push some refs to <span class="string">'/tmp/repo'</span></span><br></pre></td></tr></table></figure><p>我们可以看到 <code>--force-with-lease</code> 对于有时需要进行强制推送的 git 用户来说，是一个很有用的工具。但是，对于 <code>--force</code> 操作的所有风险来说，这并不是万能的，如果不了解它内部的工作及其注意事项，就不应该使用它。</p><p>但是，在最常见的用例中，开发人员只要按照正常的方式进行 <code>pull</code> 和 <code>push</code> 操作即可。偶尔使用下 <code>rebase</code>，这个命令提供了一些我们非常需要的，防止强制推送带来破坏的保护功能。因此，我希望在未来版本的 git（但可能 3.0 以前都不会实现），它将成为 <code>--force</code> 的默认行为，并且当前的行为将被降级到显示其实际行为的选项中，例如：<code>--force-replace-remote</code>。</p><hr><blockquote><p>原文地址：<a href="https://developer.atlassian.com/blog/2015/04/force-with-lease/" target="_blank" rel="noopener">-force considered harmful; understanding git’s –force-with-lease</a><br>原文作者：<a href="https://legacy-developer.atlassian.com/blog/authors/ssmith/" target="_blank" rel="noopener">Steve Smith</a><br>译者：<a href="https://github.com/leviding" target="_blank" rel="noopener">LeviDing</a><br>校对者：<a href="https://github.com/yifili09" target="_blank" rel="noopener">yifili09</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 的 &lt;code&gt;push --force&lt;/code&gt; 具有破坏性，因为它无条件地覆盖远程存储库，无论你在本地拥有什么。使用这个命令，可能覆盖团队成员在此期间推送的所有更改。然而，有一个更好的办法，当你需要强制推送，但仍需确保不覆盖其他人的工作时，&lt;code&gt;-force-with-lease&lt;/code&gt; 这条指令选项可以帮助到你。&lt;/p&gt;
    
    </summary>
    
      <category term="文章翻译" scheme="https://www.dingxuewen.com/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="译文" scheme="https://www.dingxuewen.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Git" scheme="https://www.dingxuewen.com/tags/Git/"/>
    
      <category term="GitHub" scheme="https://www.dingxuewen.com/tags/GitHub/"/>
    
  </entry>
  
</feed>
